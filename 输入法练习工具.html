<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>输入法练习工具</title>
    <script>
        // ============================================
        // 工具库 - TOML解析器（保持不变）
        // ============================================
        const TOML=function(){"use strict";let e="",t=0;function i(e,t=0){let i;for(;(i=e[t++])&&(" "==i||"\t"==i||"\r"==i););return t-1}function n(e){switch(e[0]){case void 0:return"";case'"':return function(e){let t,i=0,n="";for(;t=e.indexOf("\\",i)+1;){switch(n+=e.slice(i,t-1),e[t]){case"\\":n+="\\";break;case'"':n+='"';break;case"\r":"\n"==e[t+1]&&t++;case"\n":break;case"b":n+="\b";break;case"t":n+="\t";break;case"n":n+="\n";break;case"f":n+="\f";break;case"r":n+="\r";break;case"u":n+=String.fromCharCode(parseInt(e.substr(t+1,4),16)),t+=4;break;case"U":n+=String.fromCharCode(parseInt(e.substr(t+1,8),16)),t+=8;break;default:throw r(e[t])}i=t+1}return n+e.slice(i)}(e.slice(1,-1));case"'":return e.slice(1,-1);case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"+":case"-":case".":let t=e;if(-1!=t.indexOf("_")&&(t=t.replace(/_/g,"")),!isNaN(t))return+t;if("-"==e[4]&&"-"==e[7]){let t=new Date(e);if("Invalid Date"!=t.toString())return t}else if(":"==e[2]&&":"==e[5]&&e.length>=7){let t=new Date("0000-01-01T"+e+"Z");if("Invalid Date"!=t.toString())return t}return e}switch(e){case"true":return!0;case"false":return!1;case"nan":case"NaN":return!1;case"null":return null;case"inf":case"+inf":case"Infinity":case"+Infinity":return 1/0;case"-inf":case"-Infinity":return-1/0}return e}function r(i){let n=function(){let i=e[t],n=t;"\n"==i&&n--;let r=1,s=e.lastIndexOf("\n",n),a=e.indexOf("\n",n);-1==a&&(a=1/0);","!=i&&"\n"!=i||(n=s+1);if(-1==s)return{line:r,column:n+1,position:n,lineContent:e.slice(0,a).trim()};const c=n-s+1,o=e.slice(s+1,a).trim();r++;for(;-1!=(s=e.lastIndexOf("\n",s-1));)r++;return{line:r,column:c,position:n,lineContent:o}}(),r=String(n.line);return i+="\n"+r+" |  "+n.lineContent+"\n",i+=" ".repeat(r.length+n.column+2)+"^",SyntaxError(i)}function s(e,i=0,n=!1){let a,c=e[i],o=c,f=c,l=!0,u=!1;switch(c){case'"':case"'":if(a=i+1,n&&e[i+1]==c&&e[i+2]==c?(f=c+c+c,a+=2):u=!0,"'"==c)a=e.indexOf(f,a)+1;else for(;a=e.indexOf(f,a)+1;){let t=!0,i=a-1;for(;"\\"==e[--i];)t=!t;if(t)break}if(!a)throw r("Missing "+f+" closer");if(c!=f)a+=2;else if(u){let n=e.indexOf("\n",i+1)+1;if(n&&n<a)throw t=n-2,r("Forbidden end-of-line character in single-line string")}return a;case"(":f=")";break;case"{":f="}";break;case"[":f="]";break;case"<":f=">";break;default:l=!1}let h=0;for(;c=e[++i];)if(c==f){if(0==h)return i+1;h--}else if('"'==c||"'"==c){i=s(e,i,n)-1}else l&&c==o&&h++;throw r("Missing "+f)}function a(e){"string"!=typeof e&&(e=String(e));let t,i,n=-1,a="",c=[];for(;i=e[++n];)switch(i){case".":if(!a)throw r('Unexpected "."');c.push(a),a="";continue;case'"':case"'":if(t=s(e,n),t==n+2)throw r("Empty string key");a+=e.slice(n+1,t-1),n=t-1;continue;default:a+=i}return a&&c.push(a),c}function c(e,t=[]){const i=t.pop();for(let i of t){if("object"!=typeof e){throw r('["'+t.slice(0,t.indexOf(i)+1).join('"].["')+'"]'+" must be an object")}void 0===e[i]&&(e[i]={}),(e=e[i])instanceof Array&&(e=e[e.length-1])}return[e,i]}class o{constructor(){this.root={},this.data=this.root,this.inlineScopeList=[]}get isRoot(){return this.data==this.root}set(e,t){let[i,n]=c(this.data,a(e));if("string"==typeof i)throw"Wtf the scope is a string. Please report the bug";if(n in i)throw r(`Re-writing the key '${e}'`);return i[n]=t,t}push(e){if(!(this.data instanceof Array)){if(!this.isRoot)throw r("Missing key");this.data=Object.assign([],this.data),this.root=this.data}return this.data.push(e),this}use(e){return this.data=function(e,t=[]){for(let i of t){if(void 0===e)e=lastData[lastElt]={};else if("object"!=typeof e){throw r('["'+t.slice(0,t.indexOf(i)+1).join('"].["')+'"]'+" must be an object")}void 0===e[i]&&(e[i]={}),(e=e[i])instanceof Array&&(e=e[e.length-1])}return e}(this.root,a(e)),this}useArray(e){let[t,i]=c(this.root,a(e));return this.data={},void 0===t[i]&&(t[i]=[]),t[i].push(this.data),this}enter(e,t){return this.inlineScopeList.push(this.data),this.set(e,t),this.data=t,this}enterArray(e){return this.inlineScopeList.push(this.data),this.push(e),this.data=e,this}exit(){return this.data=this.inlineScopeList.pop(),this}}function f(a){"string"!=typeof a&&(a=String(a));const c=new o,f=[];e=a,t=0;let l,u,h="",d="",p=e[0],w=!0;const g=()=>{if(h=h.trimEnd(),w)h&&c.push(n(h));else{if(!h)throw r("Expected key before =");if(!d)throw r("Expected value after =");c.set(h,n(d.trimEnd()))}h="",d="",w=!0};do{switch(p){case" ":w?h&&(h+=p):d&&(d+=p);case"\t":case"\r":continue;case"#":t=e.indexOf("\n",t+1)-1,-2==t&&(t=1/0);continue;case'"':case"'":if(!w&&d){d+=p;continue}let n=e[t+1]==p&&e[t+2]==p;if(l=s(e,t,!0),w){if(h)throw r("Unexpected "+p);h+=n?e.slice(t+2,l-2):e.slice(t,l),t=l}else d=e.slice(t,l),t=l,n&&(d=d.slice(2,-2),"\n"==d[1]?d=d[0]+d.slice(2):"\r"==d[1]&&"\n"==d[2]&&(d=d[0]+d.slice(3)));if(t=i(e,t),p=e[t],p&&","!=p&&"\n"!=p&&"#"!=p&&"}"!=p&&"]"!=p&&"="!=p)throw r("Unexpected character after end of string");t--;continue;case"\n":case",":case void 0:g();continue;case"[":case"{":if(u="["==p?"]":"}",w&&!f.length){if(h)throw r("Unexpected "+p);if(l=s(e,t),"["==p&&"["==e[t+1]){if("]"!=e[l-2])throw r("Missing ]]");c.useArray(e.slice(t+2,l-2))}else c.use(e.slice(t+1,l-1));t=l}else if(w){if(h)throw r("Unexpected "+p);c.enterArray("["==p?[]:{}),f.push(u)}else{if(d)throw r("Unexpected "+p);c.enter(h.trimEnd(),"["==p?[]:{}),f.push(u),h="",w=!0}continue;case"]":case"}":if(h&&g(),f.pop()!=p)throw r("Unexpected "+p);if(c.exit(),t=i(e,t+1),p=e[t],p&&","!=p&&"\n"!=p&&"#"!=p&&"}"!=p&&"]"!=p)throw r("Unexpected character after end of scope");t--;continue;case"=":if(!w)throw r("Unexpected "+p);if(!h)throw r("Missing key before "+p);w=!1;continue;default:w?h+=p:d+=p}}while((p=e[++t])||h);if(f.length)throw r("Missing "+f.pop());return c.root}let l=null,u=null;function h(){let e="";for(let t of arguments)e+="string"==typeof t?t:t[0];return f(e)}return h.parse=f,h.parseFile=async function(e){if(l||(l=require("fs")),!u){const{promisify:e}=require("util");u=e(l.readFile)}return f(await u(e))},h.parseFileSync=function(e){return l||(l=require("fs")),f(l.readFileSync(e))},h}();

        // ============================================
        // 字体加载模块
        // ============================================
        const FontLoader = (() => {
            const FONT_LOAD_TIMEOUT = 5000

            // 检查系统字体是否存在
            const checkSystemFont = (fontName) => {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas')
                    const ctx = canvas.getContext('2d')
                    const testString = 'mmmmmmmmmmlli'

                    ctx.font = `72px "${fontName}"`
                    const baselineSize = ctx.measureText(testString).width

                    ctx.font = `72px sans-serif`
                    const fallbackSize = ctx.measureText(testString).width

                    resolve(baselineSize !== fallbackSize)
                })
            }

            // 通用字体加载函数（带超时处理）
            const loadFontWithSource = (fontName, fontSource, onError) => {
                return new Promise((resolve) => {
                    const fontFace = new FontFace(fontName, fontSource)
                    const timeoutId = setTimeout(() => {
                        console.warn(`字体加载超时: ${fontName}`)
                        resolve(false)
                    }, FONT_LOAD_TIMEOUT)

                    fontFace.load().then((loadedFace) => {
                        clearTimeout(timeoutId)
                        document.fonts.add(loadedFace)
                        resolve(true)
                    }).catch((err) => {
                        clearTimeout(timeoutId)
                        onError?.(err) || console.warn(`字体加载失败: ${fontName}`)
                        resolve(false)
                    })
                })
            }

            // 加载单个字体
            const loadFont = async (font) => {
                if (!font.name) return null

                const isSystemFont = await checkSystemFont(font.name)
                if (isSystemFont) return font.name

                if (font.base64?.length > 0 && font.type) {
                    const url = `data:font/${font.type};base64,${font.base64}`
                    if (await loadFontWithSource(font.name, `url(${url})`)) return font.name
                }

                if (font.file?.length > 0) {
                    if (await loadFontWithSource(font.name, `url(${font.file})`)) return font.name
                }

                return null
            }

            // 加载所有字体
            const loadAll = async (fonts) => {
                if (!fonts || !Array.isArray(fonts)) return null

                const loadedFontNames = []
                for (const font of fonts) {
                    const result = await loadFont(font)
                    if (result) loadedFontNames.push(result)
                }

                // 构建字体栈
                const fontContainer = document.getElementById("font-container")
                const cssFontFamily = getComputedStyle(fontContainer).fontFamily
                const fallbackFonts = cssFontFamily
                    .split(',')
                    .map(f => f.trim().replace(/^['"]|['"]$/g, ''))
                    .filter(f => f && !loadedFontNames.includes(f))
                    .join("', '")

                if (loadedFontNames.length > 0) {
                    return "'" + loadedFontNames.join("', '") + "', '" + fallbackFonts + "'"
                }
                return "'" + fallbackFonts + "'"
            }

            return { loadAll }
        })()

        // ============================================
        // 配置缓存模块
        // ============================================
        const ConfigCache = (() => {
            let lastConfigPath = null
            let lastConfigContent = null

            const isSameConfig = (path, content) => {
                return lastConfigPath === path && lastConfigContent === content
            }

            const set = (path, content) => {
                lastConfigPath = path
                lastConfigContent = content
            }

            const clear = () => {
                lastConfigPath = null
                lastConfigContent = null
            }

            return { isSameConfig, set, clear }
        })()

        // ============================================
        // 指标跟踪模块（统一管理打字速度、击键速度、键准）
        // ============================================
        const MetricsTracker = (() => {
            let updateTimer = null
            let startTime = 0
            let wordCount = 0
            let totalKeystrokes = 0
            let errorKeystrokes = 0
            let currentUpdateFn = null // 当前使用的更新函数

            // 重置所有指标
            const reset = () => {
                if (updateTimer) {
                    clearTimeout(updateTimer)
                    updateTimer = null
                }
                startTime = 0
                wordCount = 0
                totalKeystrokes = 0
                errorKeystrokes = 0
                currentUpdateFn = null
            }

            // 开始计时（并指定更新函数）
            const start = (updateFn) => {
                if (startTime === 0) {
                    startTime = new Date().getTime()
                    currentUpdateFn = updateFn
                    updateMetrics()
                }
            }

            // 停止计时
            const stop = () => {
                if (updateTimer) {
                    clearTimeout(updateTimer)
                    updateTimer = null
                }
                currentUpdateFn = null
            }

            // 增加已输入字数
            const addWordCount = (count = 1) => {
                wordCount += count
            }

            // 增加击键次数
            const addKeystroke = (isError = false) => {
                totalKeystrokes++
                if (isError) errorKeystrokes++
            }

            // 获取打字速度（字/分）
            const getTypingSpeed = () => {
                if (wordCount === 0 || startTime === 0) return 0
                const elapsedMs = new Date().getTime() - startTime
                return (wordCount * 60 * 1000) / elapsedMs
            }

            // 获取击键速度（次/秒）
            const getKeystrokeSpeed = () => {
                if (totalKeystrokes === 0 || startTime === 0) return 0
                const elapsedSeconds = (new Date().getTime() - startTime) / 1000
                return elapsedSeconds > 0 ? totalKeystrokes / elapsedSeconds : 0
            }

            // 获取键准（%）
            const getAccuracy = () => {
                if (totalKeystrokes === 0) return 100
                return ((totalKeystrokes - errorKeystrokes) / totalKeystrokes) * 100
            }

            // 获取当前统计
            const getStats = () => ({
                typingSpeed: getTypingSpeed(),
                keystrokeSpeed: getKeystrokeSpeed(),
                accuracy: getAccuracy(),
                wordCount,
                totalKeystrokes,
                errorKeystrokes
            })

            // 更新指标显示
            const updateMetrics = () => {
                if (currentUpdateFn) {
                    currentUpdateFn()
                }
                updateTimer = setTimeout(updateMetrics, 500)
            }

            // 格式化显示的函数
            const formatDisplay = (stats) => ({
                speed: `速度：${stats.typingSpeed.toFixed(2)}字/分`,
                keystroke: `击键：${stats.keystrokeSpeed.toFixed(2)}次/秒`,
                accuracy: `键准：${stats.accuracy.toFixed(1)}%`,
                progress: wordCount
            })

            // 通用指标更新函数
            const updateDisplay = (elementIds) => {
                const stats = getStats()
                const display = formatDisplay(stats)

                if (elementIds.speed) {
                    const el = typeof elementIds.speed === 'string' ? (UIComponents?.get?.(elementIds.speed) || document.getElementById(elementIds.speed)) : elementIds.speed
                    if (el) el.textContent = display.speed
                }
                if (elementIds.keystroke) {
                    const el = typeof elementIds.keystroke === 'string' ? (UIComponents?.get?.(elementIds.keystroke) || document.getElementById(elementIds.keystroke)) : elementIds.keystroke
                    if (el) el.textContent = display.keystroke
                }
                if (elementIds.accuracy) {
                    const el = typeof elementIds.accuracy === 'string' ? (UIComponents?.get?.(elementIds.accuracy) || document.getElementById(elementIds.accuracy)) : elementIds.accuracy
                    if (el) el.textContent = display.accuracy
                }
                if (elementIds.progress) {
                    const el = typeof elementIds.progress === 'string' ? (UIComponents?.get?.(elementIds.progress) || document.getElementById(elementIds.progress)) : elementIds.progress
                    if (el) el.textContent = `\t进度：${display.progress}字`
                }
            }

            return {
                reset,
                start,
                stop,
                addWordCount,
                addKeystroke,
                getStats,
                formatDisplay,
                updateDisplay
            }
        })()

        // ============================================
        // 应用状态管理
        // ============================================
        const AppState = (() => {
            const defaultState = () => ({
                curInputMax: 0,
                curInputIndex: 0,
                curTab: 0,
                totalWords: [],
                totalIndex: 0,
                inputTimer: null,
                rawAreaFonts: null,
                cleanupHandlers: []
            })

            let state = defaultState()

            const reset = () => {
                if (state.inputTimer) clearTimeout(state.inputTimer)
                state.cleanupHandlers.forEach(fn => fn())
                state = { ...defaultState(), rawAreaFonts: state.rawAreaFonts }
            }

            const addCleanup = (fn) => {
                state.cleanupHandlers.push(fn)
            }

            const get = (key) => state[key]
            const set = (key, value) => { state[key] = value }

            return { reset, addCleanup, get, set, state }
        })()

        // ============================================
        // UI 组件模块（统一管理 DOM 模板和元素引用）
        // ============================================
        const UIComponents = (() => {
            let currentRefs = {}

            // 初始化 DOM 引用缓存
            const initRefs = (ids = []) => {
                currentRefs = {}
                ids.forEach(id => {
                    currentRefs[id] = document.getElementById(id)
                })
                return currentRefs
            }

            // 获取 DOM 元素
            const get = (id) => currentRefs[id] || document.getElementById(id)

            // 渲染公共统计栏
            const renderStatsBar = (prefix = '') => `
                <div class="stats-bar">
                    ${prefix ? `
                        <span id="${prefix}ProgressLabel">进度：0/0组</span>
                        <span id="${prefix}SpeedLabel">速度：0.00字/分</span>
                        <span id="${prefix}KeystrokeSpeedLabel">击键：0.00次/秒</span>
                        <span id="${prefix}AccuracyLabel">键准：100%</span>
                    ` : `
                        <span id="progressLabel"></span>
                        <span id="speedLabel"></span>
                        <span id="keystrokeSpeedLabel">击键：0.00次/秒</span>
                        <span id="accuracyLabel">键准：100%</span>
                    `}
                </div>`

            // 渲染单选按钮组
            const renderRadioGroup = (modeConfigs, sessionStore) => {
                const savedIdx = sessionStore.get('radioMode', 0)
                return '<div class="radio-group">' +
                    modeConfigs.map((mode, i) => `
                        <label>
                            <input type="radio" name="radiobutton" data-mode="${i}" ${i === savedIdx ? 'checked' : ''}>
                            ${mode.label}
                        </label>
                    `).join('') + '</div>'
            }

            // 渲染练习设置栏
            const renderSettingsBar = (options = {}) => {
                const { showHint = true, oneTimeCount = 30, totalCount = 120, radioHtml = '', selectHtml = '' } = options
                const showHintChecked = SessionStore.get('showHint', showHint) ? 'checked' : ''
                const oc = SessionStore.get('oneTimeCount', oneTimeCount)
                const tc = SessionStore.get('totalCount', totalCount)

                return `<div class="settings-bar">
                    ${selectHtml || `
                        <div class="setting-group">
                            <label for="oneTimeCount">单次字数</label>
                            <input id="oneTimeCount" class="number-input" type="number" min="10" max="500" value="${oc}">
                        </div>
                        <div class="setting-group">
                            <label for="totalCount">练习总数</label>
                            <input id="totalCount" class="number-input" type="number" min="10" max="500" value="${tc}">
                        </div>
                        <label class="checkbox-label" for="showHint">
                            <input id="showHint" type="checkbox" ${showHintChecked}>
                            <span>显示提示</span>
                        </label>
                    `}
                    ${radioHtml}
                </div>`
            }

            // 渲染启动界面
            const renderLaunchScreen = () => `
                <div class="launch-container">
                    <div class="launch-icon">⌨️</div>
                    <h1 class="launch-title">输入法练习工具</h1>
                    <p class="launch-subtitle">选择配置文件开始练习</p>
                    <div class="launch-select">
                        <input type="file" id="configFile" accept=".toml">
                        <label for="configFile" class="file-label">选择文件</label>
                    </div>
                </div>`

            // 渲染主界面结构
            const renderMainLayout = (config, appVersion) => `
                <header class="header">
                    <h1 class="logo">${config.name || '输入法练习工具'}</h1>
                    <div class="version-info-bar">
                        <span class="version-item"><span class="version-label">应用</span><span class="version-value">${appVersion}</span></span>
                        <span class="version-divider"></span>
                        <span class="version-item"><span class="version-label">输入法</span><span class="version-value">${config.version || '-'}</span></span>
                        <span class="version-divider"></span>
                        <span class="version-item"><span class="version-label">配置</span><span class="version-value">${config.config_version || '-'}</span></span>
                    </div>
                </header>
                <nav class="nav-tabs"></nav>
                <main class="main-content"></main>`

            // 渲染分组导航
            const renderGroupNav = (groups, activeGroup) => {
                let html = '<div class="group-nav">'
                Object.keys(groups).forEach(groupName => {
                    const isActive = groupName === activeGroup ? 'active' : ''
                    html += `<button type="button" class="group-tab ${isActive}" data-group="${groupName}">${groupName}</button>`
                })
                html += `<button type="button" class="tab free-tab" id="tab-free">自由练习</button>`
                html += '</div>'
                return html
            }

            // 渲染 Tab 列表
            const renderTabs = (tabs, activeIndex) =>
                '<div class="tab-container">' +
                tabs.map(tab => `<button type="button" class="tab ${tab.index === activeIndex ? 'active' : ''}" id="tab${tab.index}">${tab.label}</button>`).join('') +
                '</div>'

            // 渲染练习模板（字根练习）
            const renderPracticeTemplate = (modeConfigs) => {
                return `<section class="card practice-card">
                    ${renderSettingsBar({ radioHtml: renderRadioGroup(modeConfigs, SessionStore) })}
                    ${renderStatsBar()}
                    <section class="content-area" id="content">
                        <div class="display-area" id="rawArea"></div>
                        <input id="userInput" autocomplete="off" spellcheck="false">
                    </section>
                </section>`
            }

            // 渲染自由练习模板
            const renderFreeTemplate = (textItems = []) => {
                const savedTextIdx = Math.min(
                    Math.max(0, SessionStore.get('freeTextIndex', 0)),
                    Math.max(0, textItems.length - 1)
                )
                const optionsHtml = textItems.map((item, idx) =>
                    `<option value="${idx}" ${idx === savedTextIdx ? 'selected' : ''}>${item.name}</option>`
                ).join('')
                const freeBatchCount = SessionStore.get('freeBatchCount', 60)
                const randomChecked = SessionStore.get('freeRandom', false) ? 'checked' : ''

                const selectHtml = `
                    <div class="setting-group">
                        <label for="freeTextSelect">选择文章</label>
                        <select id="freeTextSelect" class="text-select">${optionsHtml}</select>
                    </div>
                    <div class="setting-group">
                        <label for="freeBatchCount">每组字数</label>
                        <input id="freeBatchCount" class="number-input" type="number" min="1" max="1000" value="${freeBatchCount}">
                    </div>
                    <label class="checkbox-label" for="freeRandom">
                        <input id="freeRandom" type="checkbox" ${randomChecked}>
                        <span>随机抽字</span>
                    </label>
                    <button type="button" id="freeRefreshBtn" class="action-button">刷新</button>
                    <button type="button" id="freeNextBtn" class="action-button">下一组</button>
                `

                return `<section class="card practice-card">
                    ${renderSettingsBar({ selectHtml })}
                    ${renderStatsBar('free')}
                    <section class="content-area" id="freeContent">
                        <div class="display-area free-display-area" id="freeArea"></div>
                        <textarea id="freeUserInput" class="free-input" placeholder="在这里输入" rows="3" spellcheck="false" disabled></textarea>
                    </section>
                </section>`
            }

            // 渲染帮助内容
            const renderHelpContent = (helpContent) => helpContent || ''

            return {
                initRefs,
                get,
                renderLaunchScreen,
                renderMainLayout,
                renderGroupNav,
                renderTabs,
                renderPracticeTemplate,
                renderFreeTemplate,
                renderHelpContent
            }
        })()

        // ============================================
        // 配置验证模块
        // ============================================
        const ConfigValidator = (() => {
            const schema = {
                name: { type: 'string', default: '输入法练习工具' },
                version: { type: 'string', default: '-' },
                config_version: { type: 'string', default: '-' },
                tabs: { type: 'array', required: true },
                text: { type: 'array', required: true },
                items: { type: 'array', required: true },
                help: { type: 'array', default: [] },
                fonts: { type: 'array', default: [] },
                key_bindings: { type: 'array', default: [] }
            }

            const validate = (config) => {
                const errors = []

                if (!config || typeof config !== 'object') {
                    return { valid: false, errors: ['配置解析失败'] }
                }

                // 验证必填字段
                if (!config.tabs || !Array.isArray(config.tabs)) {
                    errors.push('缺少 tabs 配置')
                }
                if (!config.items || !Array.isArray(config.items)) {
                    errors.push('缺少 items 配置')
                }
                const textItems = config.text || []
                if (!Array.isArray(textItems) || textItems.length === 0) {
                    errors.push('缺少 text 配置')
                } else {
                    textItems.forEach((item, i) => {
                        if (!item.name || typeof item.name !== 'string') {
                            errors.push(`text[${i}] 缺少 name`)
                        }
                        if (!item.content || typeof item.content !== 'string') {
                            errors.push(`text[${i}] 缺少 content`)
                        }
                    })
                }

                // 验证 tabs 结构
                if (config.tabs) {
                    config.tabs.forEach((tab, i) => {
                        if (!tab.label) errors.push(`tabs[${i}] 缺少 label`)
                        if (tab.type === 'help') {
                            // help 类型的 index 应为长度为 1 的数组
                            if (!Array.isArray(tab.index) || tab.index.length !== 1) {
                                errors.push(`tabs[${i}] help 类型的 index 应为长度为 1 的数组`)
                            } else if (tab.index[0] < 0 || tab.index[0] >= (config.help ? config.help.length : 0)) {
                                errors.push(`tabs[${i}] index 超出 help 数组范围`)
                            }
                        } else if (!Array.isArray(tab.index) || tab.index.length === 0) {
                            errors.push(`tabs[${i}] 缺少 index`)
                        }
                        if (typeof tab.group !== 'string') errors.push(`tabs[${i}] group 应为字符串`)
                    })
                }

                return {
                    valid: errors.length === 0,
                    errors,
                    data: config
                }
            }

            return { validate }
        })()

        // ============================================
        // 键盘事件处理模块（共享）
        // ============================================
        const KeyboardHandler = (() => {
            const createHandler = () => {
                const handler = (e) => {
                    // 只在输入框激活时统计
                    const userInput = UIComponents.get('userInput') || UIComponents.get('freeUserInput')
                    if (!userInput || document.activeElement !== userInput) return

                    // Backspace 和 Del 视为错误按键
                    const isError = e.key === 'Backspace' || e.key === 'Delete'
                    MetricsTracker.addKeystroke(isError)
                }
                return handler
            }

            const bind = () => {
                const handler = createHandler()
                document.addEventListener('keydown', handler)
                AppState.addCleanup(() => document.removeEventListener('keydown', handler))
            }

            return { bind }
        })()

        // ============================================
        // 会话存储封装
        // ============================================
        const SessionStore = (() => {
            const get = (key, defaultVal) => {
                const val = sessionStorage.getItem(key)
                if (val === null) return defaultVal
                // 处理布尔值
                if (val === 'true') return true
                if (val === 'false') return false
                // 处理数字
                const num = parseFloat(val)
                return isNaN(num) ? val : num
            }

            const set = (key, value) => {
                sessionStorage.setItem(key, String(value))
            }

            return { get, set }
        })()

        // ============================================
        // 工具函数
        // ============================================
        const Utils = (() => {
            const shuffleArray = (arr) => {
                const indices = [...Array(arr.length).keys()]
                for (let i = 0; i < indices.length; i++) {
                    const j = Math.floor(Math.random() * indices.length)
                    ;[indices[i], indices[j]] = [indices[j], indices[i]]
                }
                return indices.map(i => arr[i])
            }

            const generateRandomIndices = (size, max) => {
                const result = []
                for (let i = 0; i < size; i++) { result.push(Math.floor(Math.random() * max)) }
                return result
            }

            const debounce = (fn, delay) => {
                let timer = null
                return (...args) => {
                    if (timer) clearTimeout(timer)
                    timer = setTimeout(() => fn(...args), delay)
                }
            }

            // 根据索引列表获取单词
            const getWordsByIndex = (items, indices) => {
                const words = []
                for (const i of indices) {
                    const objs = items[i]
                    for (const key in objs) {
                        objs[key].forEach(code => words.push({ key, code }))
                    }
                }
                return words
            }

            // 构建分组数据
            const buildGroups = (tabs, defaultGroup = '默认') => {
                const groups = {}
                tabs.forEach((tab, i) => {
                    const groupName = tab.group || defaultGroup
                    if (!groups[groupName]) groups[groupName] = []
                    groups[groupName].push({ ...tab, index: i })
                })
                return groups
            }

            return { shuffleArray, generateRandomIndices, debounce, getWordsByIndex, buildGroups }
        })()

        // ============================================
        // 主应用逻辑
        // ============================================
        const App = (() => {
            const appVersion = "2.0.0-beta1"
            let config = {}
            let compiledKeyBindings = []

            const modeConfigs = [
                { name: "sequential", label: "顺序单次", handler: (words) => words },
                { name: "shuffled", label: "乱序单次", handler: (words) => Utils.shuffleArray(words) },
                { name: "repeated", label: "乱序重复", handler: (words) => Utils.generateRandomIndices(SessionStore.get("totalCount", 120), words.length).map(i => words[i]) }
            ]

            // 清理资源
            const cleanup = () => {
                // 清理 FreeModule
                FreeModule.cleanup()
                MetricsTracker.reset()
                AppState.reset()
            }

            // 编译快捷键
            const compileKeyBindings = () => {
                compiledKeyBindings = []
                const bindings = (config && config.key_bindings) ? config.key_bindings : []
                for (const binding of bindings) {
                    const key = binding.key.toLowerCase()
                    const parts = key.split('+').map(p => p.trim()).filter(p => p)
                    const modifiers = parts.filter(p => ['ctrl', 'alt', 'shift', 'meta'].includes(p))
                    const keyPart = parts.find(p => !['ctrl', 'alt', 'shift', 'meta'].includes(p))
                    if (keyPart) {
                        compiledKeyBindings.push({ modifiers, keyPart, command: binding.command })
                    }
                }
            }

            // 初始化快捷键
            const initKeyBindings = () => {
                compileKeyBindings()
                if (compiledKeyBindings.length === 0) return

                const triggerContentReload = () => {
                    const curTab = AppState.get('curTab')
                    if (curTab === 'free') {
                        const refreshBtn = document.getElementById('freeRefreshBtn')
                        if (refreshBtn) refreshBtn.click()
                        return
                    }
                    if (curTab === undefined || curTab === null) return
                    startPractice(curTab)
                }

                const triggerContentNext = () => {
                    const curTab = AppState.get('curTab')
                    if (curTab === 'free') {
                        const nextBtn = document.getElementById('freeNextBtn')
                        if (nextBtn) nextBtn.click()
                        return
                    }

                    if (!loadNextBatch()) {
                        const userInput = UIComponents.get('userInput')
                        if (userInput) userInput.setAttribute('disabled', 'true')
                        stopMetricsTracking()
                    }
                }

                const executeBindingCommand = (command) => {
                    if (command === 'content_reload') {
                        triggerContentReload()
                        return true
                    }
                    if (command === 'content_next') {
                        triggerContentNext()
                        return true
                    }
                    return false
                }

                const handler = (e) => {
                    for (const binding of compiledKeyBindings) {
                        const ctrlMatch = binding.modifiers.includes('ctrl') ? e.ctrlKey : !e.ctrlKey
                        const altMatch = binding.modifiers.includes('alt') ? e.altKey : !e.altKey
                        const shiftMatch = binding.modifiers.includes('shift') ? e.shiftKey : !e.shiftKey
                        const metaMatch = binding.modifiers.includes('meta') ? e.metaKey : !e.metaKey
                        const keyMatch = e.key.toLowerCase() === binding.keyPart

                        if (ctrlMatch && altMatch && shiftMatch && metaMatch && keyMatch) {
                            e.preventDefault()
                            executeBindingCommand(binding.command)
                            break
                        }
                    }
                }
                document.addEventListener('keydown', handler)
                AppState.addCleanup(() => document.removeEventListener('keydown', handler))
            }

            // 更新指标显示（使用 MetricsTracker）
            const updateMetricsDisplay = () => {
                MetricsTracker.updateDisplay({
                    speed: UIComponents.get('speedLabel'),
                    keystroke: UIComponents.get('keystrokeSpeedLabel'),
                    accuracy: UIComponents.get('accuracyLabel'),
                    progress: UIComponents.get('progressLabel')
                })
                // 单独更新进度显示（需要 totalWords 长度）
                const progressLabel = UIComponents.get('progressLabel')
                if (progressLabel) {
                    progressLabel.textContent = `\t进度：${MetricsTracker.getStats().wordCount}/${AppState.get('totalWords').length}字`
                }
            }

            // 启动指标跟踪
            const startMetricsTracking = () => {
                MetricsTracker.reset()
                MetricsTracker.start(updateMetricsDisplay)
            }

            // 停止指标跟踪
            const stopMetricsTracking = () => {
                MetricsTracker.stop()
            }

            // 更新占位符
            const updatePlaceholder = () => {
                const curInputIndex = AppState.get('curInputIndex')
                const word = UIComponents.get(`word${curInputIndex}`)
                if (word) {
                    const showHint = SessionStore.get('showHint', true)
                    UIComponents.get('userInput').setAttribute("placeholder", showHint ? word.getAttribute("key") : "")
                }
            }

            // 获取当前单词
            const getCurrentWord = () => {
                const curInputIndex = AppState.get('curInputIndex')
                const curInputMax = AppState.get('curInputMax')
                if (curInputIndex >= curInputMax) return null
                return UIComponents.get(`word${curInputIndex}`)
            }

            // 加载下一批
            const loadNextBatch = () => {
                const totalWords = AppState.get('totalWords')
                const totalIndex = AppState.get('totalIndex')
                const lastCount = totalWords.length - totalIndex
                if (lastCount <= 0) return false

                const oneTimeCount = SessionStore.get('oneTimeCount', 30)
                const wordNeed = Math.min(lastCount, oneTimeCount)
                AppState.set('curInputMax', wordNeed)
                AppState.set('curInputIndex', 0)

                const rawArea = UIComponents.get('rawArea')
                rawArea.innerHTML = ''

                totalWords.slice(totalIndex, totalIndex + wordNeed).forEach((word, idx) => {
                    const span = document.createElement("span")
                    span.textContent = word.code
                    span.setAttribute("key", word.key)
                    span.id = `word${idx}`
                    span.style.color = "var(--text-tertiary)"
                    rawArea.appendChild(span)
                })

                AppState.set('totalIndex', totalIndex + wordNeed)
                updatePlaceholder()
                return true
            }

            // 处理输入
            const handleInput = () => {
                const curInputMax = AppState.get('curInputMax')
                const curInputIndex = AppState.get('curInputIndex')

                if (curInputIndex >= curInputMax) return

                let inputTimer = AppState.get('inputTimer')
                if (inputTimer) clearTimeout(inputTimer)

                inputTimer = setTimeout(() => {
                    const word = getCurrentWord()
                    if (!word) {
                        AppState.set('inputTimer', null)
                        return
                    }

                    const key = word.getAttribute("key")
                    const userInput = UIComponents.get('userInput')
                    const val = userInput.value

                    if (val.length < key.length) {
                        AppState.set('inputTimer', null)
                        return
                    }

                    if (val.toLowerCase() === key) {
                        MetricsTracker.start()
                        MetricsTracker.addWordCount()
                        AppState.set('curInputIndex', curInputIndex + 1)

                        const totalWords = AppState.get('totalWords')
                        UIComponents.get('progressLabel').textContent = `\t进度：${MetricsTracker.getStats().wordCount}/${totalWords.length}字`
                        word.style.color = "var(--text-primary)"
                        userInput.value = ""
                        updatePlaceholder()
                    } else {
                        MetricsTracker.addKeystroke(true) // 错误按键
                        word.style.color = "var(--error)"
                        userInput.value = ""
                        userInput.setAttribute("placeholder", key)
                    }

                    AppState.set('inputTimer', null)

                    if (AppState.get('curInputIndex') >= AppState.get('curInputMax')) {
                        if (!loadNextBatch()) {
                            userInput.setAttribute("disabled", "true")
                            stopMetricsTracking()
                        }
                    }
                }, 50)

                AppState.set('inputTimer', inputTimer)
            }

            // 初始化DOM引用
            const initDomReferences = () => {
                const userInput = UIComponents.get('userInput')

                if (userInput) {
                    userInput.oninput = handleInput
                }

                // 使用共享的键盘事件处理器
                KeyboardHandler.bind()

                const oneTimeCount = UIComponents.get("oneTimeCount")
                const totalCount = UIComponents.get("totalCount")

                if (oneTimeCount) {
                    oneTimeCount.addEventListener('change', () => startPractice(AppState.get('curTab')))
                }
                if (totalCount) {
                    totalCount.addEventListener('change', () => startPractice(AppState.get('curTab')))
                }

                // 点击聚焦
                const clickHandler = (e) => {
                    if (userInput && document.activeElement !== userInput &&
                        e.target.id !== 'oneTimeCount' &&
                        e.target.id !== 'totalCount') {
                        userInput.focus({ preventScroll: true })
                    }
                }
                document.addEventListener('click', clickHandler)
                AppState.addCleanup(() => document.removeEventListener('click', clickHandler))
            }

            // 更新标签样式
            const updateTabStyles = (activateIdx) => {
                document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"))
                if (activateIdx !== null) {
                    if (activateIdx === 'free') {
                        document.getElementById('tab-free').classList.add("active")
                    } else {
                        UIComponents.get(`tab${activateIdx}`).classList.add("active")
                    }
                }
            }

            // 控制 free 模式下子 tab 区域显隐
            const setFreeNavMode = (isFreeType) => {
                const nav = document.querySelector('.nav-tabs')
                if (!nav) return
                const isFree = Boolean(isFreeType)
                nav.classList.toggle('is-free-mode', isFree)
                if (isFree) {
                    document.querySelectorAll('.group-tab').forEach(tab => tab.classList.remove('active'))
                }
            }

            // 切换输入区域
            const toggleInputArea = (val) => {
                const contentCard = UIComponents.get('content') || UIComponents.get('freeContent')
                if (contentCard) {
                    if (val) {
                        contentCard.style.removeProperty('display')
                    } else {
                        contentCard.style.display = 'none'
                    }
                }
                const userInput = UIComponents.get('userInput') || UIComponents.get('freeUserInput')
                if (userInput) userInput.value = ""
            }

            // 显示模板
            const showTemplate = (templateId, helpIndex = 0, textItems = [], modeConfigs = []) => {
                const mainEl = document.querySelector("main")

                if (templateId === "help-template") {
                    mainEl.innerHTML = UIComponents.renderHelpContent(config.help?.[helpIndex])
                    return
                }

                let content = ''
                if (templateId === "practice-template") {
                    content = UIComponents.renderPracticeTemplate(modeConfigs)
                } else if (templateId === "free-template") {
                    content = UIComponents.renderFreeTemplate(textItems)
                }

                mainEl.innerHTML = content

                if (templateId === "practice-template") {
                    bindPracticeTemplateEvents()
                }
            }



                                                // 绑定练习模板事件
                                    const bindPracticeTemplateEvents = () => {
                                        // 单选按钮事件
                                        const radioButtons = document.querySelectorAll('input[name="radiobutton"]')
                                        radioButtons.forEach(input => {
                                            input.onclick = () => {
                                                const modeIdx = parseInt(input.dataset.mode)
                                                SessionStore.set('radioMode', modeIdx)
                                                startPractice(AppState.get('curTab'))
                                            }
                                        })

                                        // 提示复选框
                                        const hintCheckbox = document.getElementById('showHint')
                                        if (hintCheckbox) {
                                            hintCheckbox.onchange = (e) => {
                                                SessionStore.set('showHint', e.target.checked)
                                                updatePlaceholder()
                                            }
                                        }

                                        // 数字输入框
                                        const oneTimeCountInput = document.getElementById('oneTimeCount')
                                        if (oneTimeCountInput) {
                                            oneTimeCountInput.onchange = (e) => SessionStore.set('oneTimeCount', e.target.value)
                                        }

                                        const totalCountInput = document.getElementById('totalCount')
                                        if (totalCountInput) {
                                            totalCountInput.onchange = (e) => SessionStore.set('totalCount', e.target.value)
                                        }
                                    }
            // 初始化标签
            const initTabs = () => {
                const nav = document.querySelector(".nav-tabs")

                // 按 group 分组
                const groups = Utils.buildGroups(config.tabs)
                const firstGroup = Object.keys(groups)[0] || null

                // 渲染分组导航（包含 free tab）
                nav.innerHTML = UIComponents.renderGroupNav(groups, null)

                // 绑定 free tab 点击事件
                const freeTab = document.getElementById('tab-free')
                if (freeTab) {
                    freeTab.onclick = () => startPractice('free')
                }

                // 添加当前分组的 tabs 容器
                const tabContainer = document.createElement("div")
                tabContainer.className = "tab-container"
                nav.appendChild(tabContainer)

                // 绑定分组点击事件
                document.querySelectorAll('.group-tab').forEach(btn => {
                    btn.onclick = () => switchGroup(btn.dataset.group)
                })

                // 默认显示第一个分组
                if (firstGroup) {
                    switchGroup(firstGroup, false)
                }
            }

            // 切换分组
            const switchGroup = (groupName, updateActiveTab = true) => {
                setFreeNavMode(false)

                // 更新分组样式
                const groupTab = document.querySelector(`.group-tab[data-group="${groupName}"]`)
                if (groupTab) {
                    document.querySelectorAll(".group-tab").forEach(t => t.classList.remove("active"))
                    groupTab.classList.add("active")
                }

                // 获取分组数据
                const groups = Utils.buildGroups(config.tabs)
                const tabs = groups[groupName] || []
                const tabContainer = document.querySelector(".tab-container")
                tabContainer.innerHTML = UIComponents.renderTabs(tabs, null)

                // 绑定 tab 点击事件
                tabs.forEach(tab => {
                    const btn = document.getElementById(`tab${tab.index}`)
                    if (btn) {
                        btn.onclick = () => {
                            if (tab.type === "help") {
                                displayHelp(tab.index[0])
                            } else {
                                startPractice(tab.index)
                            }
                        }
                    }
                })

                // 激活该分组的第一个 tab
                if (updateActiveTab && tabs.length > 0) {
                    const firstTab = tabs[0]
                    if (firstTab.type === "help") {
                        displayHelp(firstTab.index[0])
                    } else {
                        startPractice(firstTab.index)
                    }
                }
            }

            // 显示帮助
            const displayHelp = (helpIndex = 0) => {
                stopMetricsTracking()
                setFreeNavMode(false)
                updateTabStyles(helpIndex)
                const mainEl = document.querySelector("main")
                mainEl.innerHTML = UIComponents.renderHelpContent(config.help?.[helpIndex])

                // 切换到 help 所在的分组
                const helpTab = config.tabs.find(t => t.type === 'help' && t.index[0] === helpIndex)
                if (helpTab) {
                    const groupName = helpTab.group || '默认'
                    const groupTab = document.querySelector(`.group-tab[data-group="${groupName}"]`)
                    if (groupTab) {
                        document.querySelectorAll(".group-tab").forEach(t => t.classList.remove("active"))
                        groupTab.classList.add("active")
                    }
                }
            }

            // 辅助函数：更新分组高亮
            const updateGroupHighlight = (groupName) => {
                const groupTab = document.querySelector(`.group-tab[data-group="${groupName}"]`)
                if (groupTab) {
                    document.querySelectorAll(".group-tab").forEach(t => t.classList.remove("active"))
                    groupTab.classList.add("active")
                }
            }

            // 开始练习
            const startPractice = (val, type = 'default') => {
                cleanup()
                updateTabStyles(val)

                // 判断是否为 free 模式
                const isFreeType = val === 'free'
                setFreeNavMode(isFreeType)

                // 根据类型显示不同的模板
                if (isFreeType) {
                    const textItems = (config.text || []).map(item => ({ name: item.name, content: item.content }))
                    showTemplate("free-template", 0, textItems)
                } else {
                    showTemplate("practice-template", 0, [], modeConfigs)
                }

                // 初始化 DOM 引用缓存
                UIComponents.initRefs([
                    'rawArea', 'userInput', 'freeUserInput',
                    'speedLabel', 'progressLabel', 'keystrokeSpeedLabel', 'accuracyLabel',
                    'freeProgressLabel', 'freeSpeedLabel', 'freeKeystrokeSpeedLabel', 'freeAccuracyLabel',
                    'freeTextSelect', 'freeBatchCount', 'freeRandom', 'freeNextBtn', 'freeRefreshBtn',
                    'oneTimeCount', 'totalCount', 'showHint'
                ])

                initDomReferences()
                initKeyBindings() // 重新注册快捷键（cleanup会移除）
                toggleInputArea(true)

                const rawArea = UIComponents.get('rawArea') || UIComponents.get('freeArea')
                const userInput = isFreeType
                    ? UIComponents.get('freeUserInput')
                    : UIComponents.get('userInput')

                if (!rawArea || !userInput) {
                    console.error('startPractice: rawArea or userInput not found')
                    return
                }

                rawArea.style.fontFamily = AppState.get('rawAreaFonts') || 'inherit'

                if (!isFreeType) {
                    userInput.removeAttribute("disabled")
                    updatePlaceholder()
                    userInput.focus({ preventScroll: true })
                }

                AppState.set('totalIndex', 0)
                AppState.set('curTab', val)

                // 判断是否为 free 类型
                if (isFreeType) {
                    // 使用自由练习模块，从 config.text 获取文章内容
                    const textItems = (config.text || []).map(item => ({ name: item.name, content: item.content }))
                    FreeModule.init(textItems)
                    FreeModule.bindEvents()
                } else {
                    // 原来的字根练习逻辑
                    const allWords = Utils.getWordsByIndex(config.items, config.tabs[val].index)
                    const modeIdx = SessionStore.get('radioMode', 0)
                    AppState.set('totalWords', modeConfigs[modeIdx].handler(allWords))

                    loadNextBatch()
                    const progressLabel = UIComponents.get('progressLabel')
                    if (progressLabel) {
                        progressLabel.textContent = `\t进度：0/${AppState.get('totalWords').length}字`
                    }

                    // 启动指标跟踪
                    startMetricsTracking()
                }

                // 切换到当前 tab 所在的分组（free 模式不切换分组）
                if (!isFreeType) {
                    const curTabConfig = config.tabs[val]
                    if (curTabConfig) {
                        updateGroupHighlight(curTabConfig.group || '默认')
                    }
                }
            }

            // 加载配置
            const loadConfig = async (text, filePath) => {
                // 检查缓存
                if (ConfigCache.isSameConfig(filePath, text)) {
                    // 刷新快捷键
                    initTabs()
                    initKeyBindings()
                    displayHelp()
                    return true
                }

                let newConfig
                try {
                    newConfig = TOML.parse(text)
                } catch (err) {
                    console.error('TOML解析失败:', err)
                    throw new Error('配置解析失败: ' + err.message)
                }

                // 验证配置
                const validation = ConfigValidator.validate(newConfig)
                if (!validation.valid) {
                    console.error('配置验证失败:', validation.errors)
                    throw new Error('配置验证失败:\n' + validation.errors.join('\n'))
                }

                config = validation.data
                ConfigCache.set(filePath, text)

                // 设置标题和版本
                document.title = config.name || '输入法练习工具'

                // 恢复主界面结构
                document.querySelector('.app-container').innerHTML = UIComponents.renderMainLayout(config, appVersion)

                // 初始化
                initTabs()
                initKeyBindings()
                displayHelp(0)

                // 加载字体
                try {
                    const fontFamily = await FontLoader.loadAll(config.fonts)
                    AppState.set('rawAreaFonts', fontFamily)
                } catch (err) {
                    console.error('字体加载失败:', err)
                }

                return true
            }

            // 选择配置
            const onConfigSelected = async (e) => {
                const file = e.target.files[0]
                if (!file) return

                try {
                    const text = await file.text()
                    await loadConfig(text, file.name)
                } catch (err) {
                    console.error('加载配置失败:', err, err.stack)
                    alert('加载配置失败: ' + err.message + '\n请查看控制台获取详情')
                }
            }

            // 显示启动界面
            const showLaunchScreen = () => {
                document.querySelector('.app-container').innerHTML = UIComponents.renderLaunchScreen()
                UIComponents.get('configFile').addEventListener('change', onConfigSelected)
            }

            // 初始化
            const init = () => {
                cleanup()
                showLaunchScreen()
            }

            return { init }
        })()

        // ============================================
        // 自由练习模块（free tab 类型专用）
        // ============================================
        const FreeModule = (() => {
            let textItems = []
            let cachedChars = []
            let cacheIndex = 0
            let currentBatch = ''
            let isComposing = false
            let currentGroup = 0
            let totalGroups = 0
            let countedCorrectFlags = []
            let isBatchLocked = false

            const elementIds = {
                progress: 'freeProgressLabel',
                speed: 'freeSpeedLabel',
                keystroke: 'freeKeystrokeSpeedLabel',
                accuracy: 'freeAccuracyLabel'
            }

            const freeDebugEnabled = SessionStore.get('freeDebug', true)
            const freeLog = (...args) => {
                if (freeDebugEnabled) {
                    console.log('[FreeDebug]', ...args)
                }
            }

            // 某些输入法不会稳定触发 compositionstart/end，这里用末尾拼音串做兜底判定
            const hasTrailingPhonetic = (val) => /[A-Za-z']+$/.test(val)

            const clampBatchCount = (val) => {
                const num = parseInt(val, 10)
                if (!Number.isFinite(num)) return 60
                return Math.min(1000, Math.max(1, num))
            }

            const getBatchCount = () => {
                const batchInput = document.getElementById('freeBatchCount')
                const count = clampBatchCount(batchInput ? batchInput.value : 60)
                if (batchInput) batchInput.value = count
                SessionStore.set('freeBatchCount', count)
                return count
            }

            const updateProgress = () => {
                const progressLabel = document.getElementById(elementIds.progress)
                if (progressLabel) {
                    progressLabel.textContent = `进度：${currentGroup}/${totalGroups}组`
                }
            }

            const setTotalGroupsByBatch = () => {
                const batchCount = getBatchCount()
                totalGroups = cachedChars.length > 0 ? Math.ceil(cachedChars.length / batchCount) : 0
                if (currentGroup > totalGroups) currentGroup = totalGroups
                updateProgress()
            }

            const getSelectedText = () => {
                const textSelect = document.getElementById('freeTextSelect')
                const idx = textSelect ? parseInt(textSelect.value, 10) || 0 : 0
                return { idx, item: textItems[idx] || textItems[0] || { content: '' } }
            }

            const isRandomMode = () => {
                const randomInput = document.getElementById('freeRandom')
                return !!(randomInput && randomInput.checked)
            }

            const getNextButton = () => document.getElementById('freeNextBtn')
            const getRefreshButton = () => document.getElementById('freeRefreshBtn')

            const resetMetricsDisplay = () => {
                const speedLabel = document.getElementById(elementIds.speed)
                const keystrokeLabel = document.getElementById(elementIds.keystroke)
                const accuracyLabel = document.getElementById(elementIds.accuracy)
                if (speedLabel) speedLabel.textContent = '速度：0.00字/分'
                if (keystrokeLabel) keystrokeLabel.textContent = '击键：0.00次/秒'
                if (accuracyLabel) accuracyLabel.textContent = '键准：100%'
            }

            const updateMetricsDisplay = () => {
                MetricsTracker.updateDisplay({
                    speed: elementIds.speed,
                    keystroke: elementIds.keystroke,
                    accuracy: elementIds.accuracy
                })
            }

            const setInputEnabled = (enabled) => {
                const userInput = document.getElementById('freeUserInput')
                if (!userInput) return
                if (enabled) {
                    userInput.removeAttribute('disabled')
                    userInput.focus({ preventScroll: true })
                } else {
                    userInput.setAttribute('disabled', 'true')
                }
            }

            const renderPlaceholder = (message = '请选择文章开始练习') => {
                const freeArea = document.getElementById('freeArea')
                if (!freeArea) return
                freeArea.innerHTML = `<div class="free-placeholder">${message}</div>`
            }

            const renderBatch = (text) => {
                const freeArea = document.getElementById('freeArea')
                if (!freeArea) return
                freeArea.innerHTML = ''
                freeArea.style.fontFamily = AppState.get('rawAreaFonts') || 'inherit'

                text.split('').forEach((char, idx) => {
                    const span = document.createElement('span')
                    span.id = `free-char-${idx}`
                    span.textContent = char
                    span.dataset.char = char
                    freeArea.appendChild(span)
                })
            }

            const restartCurrentBatch = () => {
                if (!currentBatch) {
                    freeLog('restartCurrentBatch:skip-empty-batch')
                    return
                }

                isBatchLocked = false
                countedCorrectFlags = Array.from({ length: currentBatch.length }, () => false)

                MetricsTracker.reset()
                resetMetricsDisplay()

                const userInput = document.getElementById('freeUserInput')
                if (userInput) {
                    userInput.value = ''
                    userInput.placeholder = '此处输入'
                    userInput.removeAttribute('disabled')
                }

                renderBatch(currentBatch)
                setInputEnabled(true)

                const nextBtn = getNextButton()
                if (nextBtn) {
                    nextBtn.textContent = cacheIndex >= cachedChars.length ? '重新开始' : '下一组'
                }

                freeLog('restartCurrentBatch', { batchLength: currentBatch.length, currentGroup, totalGroups })
            }

            const rebuildCache = () => {
                const { idx, item } = getSelectedText()
                const content = item?.content || ''
                const chars = Array.from(content)
                const randomMode = isRandomMode()

                SessionStore.set('freeTextIndex', idx)
                SessionStore.set('freeRandom', randomMode)

                cachedChars = randomMode ? Utils.shuffleArray(chars) : chars
                freeLog('rebuildCache', { textIndex: idx, randomMode, textLength: chars.length, cachedLength: cachedChars.length })

                cacheIndex = 0
                currentBatch = ''
                countedCorrectFlags = []
                isBatchLocked = false
                currentGroup = 0

                setTotalGroupsByBatch()
                MetricsTracker.reset()
                resetMetricsDisplay()

                const userInput = document.getElementById('freeUserInput')
                if (userInput) {
                    userInput.value = ''
                    userInput.placeholder = '在这里输入'
                }

                if (cachedChars.length === 0) {
                    setInputEnabled(false)
                    renderPlaceholder('当前文章为空，请选择其他文章')

                    const nextBtn = getNextButton()
                    if (nextBtn) {
                        nextBtn.textContent = '下一组'
                    }

                    const refreshBtn = getRefreshButton()
                    if (refreshBtn) {
                        refreshBtn.setAttribute('disabled', 'true')
                    }
                    return
                }

                loadNextBatch()
            }

            const loadNextBatch = () => {
                freeLog('loadNextBatch:begin', { cacheIndex, cachedLength: cachedChars.length })

                if (cachedChars.length === 0) {
                    freeLog('loadNextBatch:empty-cache')
                    setInputEnabled(false)
                    renderPlaceholder('当前文章为空，请选择其他文章')
                    return
                }

                if (cacheIndex >= cachedChars.length) {
                    freeLog('loadNextBatch:rebuild-required')
                    rebuildCache()
                    return
                }

                const batchCount = getBatchCount()
                setTotalGroupsByBatch()

                const start = cacheIndex
                const end = Math.min(start + batchCount, cachedChars.length)
                currentBatch = cachedChars.slice(start, end).join('')
                cacheIndex = end
                countedCorrectFlags = Array.from({ length: currentBatch.length }, () => false)
                isBatchLocked = false
                currentGroup = totalGroups > 0 ? Math.floor(start / batchCount) + 1 : 0
                updateProgress()

                freeLog('loadNextBatch:ready', { start, end, batchLength: currentBatch.length, cacheIndex })

                MetricsTracker.reset()
                resetMetricsDisplay()

                const userInput = document.getElementById('freeUserInput')
                if (userInput) {
                    userInput.value = ''
                    userInput.placeholder = '在这里输入'
                }

                renderBatch(currentBatch)
                setInputEnabled(true)

                const nextBtn = getNextButton()
                if (nextBtn) {
                    nextBtn.textContent = cacheIndex >= cachedChars.length ? '重新开始' : '下一组'
                }

                const refreshBtn = getRefreshButton()
                if (refreshBtn) {
                    refreshBtn.removeAttribute('disabled')
                }
            }

            const finishCurrentBatch = () => {
                if (isBatchLocked) return
                isBatchLocked = true

                MetricsTracker.stop()
                updateMetricsDisplay()

                setInputEnabled(false)

                freeLog('finishCurrentBatch', { currentGroup, totalGroups, cacheIndex, cachedLength: cachedChars.length })

                const nextBtn = getNextButton()
                if (nextBtn) {
                    nextBtn.textContent = cacheIndex >= cachedChars.length ? '重新开始' : '下一组'
                }

                const userInput = document.getElementById('freeUserInput')
                if (userInput) {
                    userInput.placeholder = '点击下一组继续练习'
                }
            }

            const handleCommittedInput = () => {
                const userInput = document.getElementById('freeUserInput')
                if (!userInput || !currentBatch || isBatchLocked) {
                    freeLog('handleCommittedInput:skip', {
                        hasInput: !!userInput,
                        batchLength: currentBatch ? currentBatch.length : 0,
                        isBatchLocked
                    })
                    return
                }

                if (userInput.value.length > currentBatch.length) {
                    userInput.value = userInput.value.slice(0, currentBatch.length)
                }

                const val = userInput.value
                const inputLen = Math.min(val.length, currentBatch.length)
                let correctCount = 0

                for (let i = 0; i < currentBatch.length; i++) {
                    const span = document.getElementById(`free-char-${i}`)
                    if (!span) continue

                    span.style.background = 'transparent'
                    span.classList.remove('error')

                    if (i < inputLen) {
                        const isCorrect = val[i] === currentBatch[i]
                        if (isCorrect) {
                            correctCount++
                            span.style.color = 'var(--text-primary)'
                            if (!countedCorrectFlags[i]) {
                                countedCorrectFlags[i] = true
                                MetricsTracker.addWordCount(1)
                            }
                        } else {
                            span.style.color = 'var(--error)'
                            span.style.background = 'var(--error-subtle)'
                            span.classList.add('error')
                        }
                    } else {
                        span.style.color = 'var(--text-tertiary)'
                    }
                }

                freeLog('handleCommittedInput:compare', {
                    valLength: val.length,
                    batchLength: currentBatch.length,
                    correctCount
                })

                if (val.length > 0) {
                    MetricsTracker.start(updateMetricsDisplay)
                }

                if (inputLen === currentBatch.length) {
                    freeLog('handleCommittedInput:batch-finished')
                    finishCurrentBatch()
                }
            }

            // 初始化自由练习
            const init = (items = []) => {
                textItems = items

                const freeArea = document.getElementById('freeArea')
                const userInput = document.getElementById('freeUserInput')
                if (!freeArea || !userInput) {
                    console.error('FreeModule init failed: freeArea or userInput not found')
                    return
                }

                freeArea.style.fontFamily = AppState.get('rawAreaFonts') || 'inherit'
                rebuildCache()
            }

            // 处理用户输入（仅供 compositionend 调用）
            const handleInput = () => {
                handleCommittedInput()
            }

            // 绑定事件
            const bindEvents = () => {
                const userInput = document.getElementById('freeUserInput')
                const textSelect = document.getElementById('freeTextSelect')
                const randomInput = document.getElementById('freeRandom')
                const batchCountInput = document.getElementById('freeBatchCount')
                const nextBtn = getNextButton()
                const refreshBtn = getRefreshButton()

                if (textSelect) {
                    textSelect.onchange = () => rebuildCache()
                }

                if (randomInput) {
                    randomInput.onchange = () => rebuildCache()
                }

                if (batchCountInput) {
                    batchCountInput.onchange = (e) => {
                        const count = clampBatchCount(e.target.value)
                        e.target.value = count
                        SessionStore.set('freeBatchCount', count)
                        rebuildCache()
                    }
                }

                if (nextBtn) {
                    nextBtn.onclick = () => loadNextBatch()
                }

                if (refreshBtn) {
                    refreshBtn.onclick = () => restartCurrentBatch()
                }

                if (userInput) {
                    userInput.oninput = (e) => {
                        const inputType = e?.inputType || ''
                        const eventComposing = !!e?.isComposing
                        const value = userInput.value

                        freeLog('event:input', {
                            inputType,
                            eventComposing,
                            stateComposing: isComposing,
                            value
                        })

                        // IME 中间态：值末尾仍是拼音串时不判定；候选上屏后再判定
                        if (inputType === 'insertCompositionText' || inputType === 'deleteCompositionText') {
                            if (hasTrailingPhonetic(value)) {
                                freeLog('event:input:ignored-composing-tail', { inputType, value })
                                return
                            }
                            freeLog('event:input:commit-detected', { inputType, value })
                            handleCommittedInput()
                            return
                        }

                        if (isComposing || eventComposing) {
                            freeLog('event:input:ignored-composing-flag', { inputType })
                            return
                        }

                        handleCommittedInput()
                    }
                }
            }

            // 清理资源
            const cleanup = () => {
                MetricsTracker.stop()
                textItems = []
                cachedChars = []
                cacheIndex = 0
                currentBatch = ''
                isComposing = false
                currentGroup = 0
                totalGroups = 0
                countedCorrectFlags = []
                isBatchLocked = false
            }

            return { init, bindEvents, cleanup, handleInput }
        })()

        // 启动应用
        window.addEventListener('load', App.init)
    </script>
    <style>
            :root {
                --primary: #4f46e5;
                --primary-strong: #4338ca;
                --primary-soft: #eef2ff;
                --accent: #06b6d4;
                --danger: #ef4444;
                --danger-soft: #fee2e2;
                --bg: #f5f7ff;
                --card-bg: #ffffff;
                --text-main: #1f2a44;
                --text-sub: #64748b;
                --text-faint: #cbd5e1;
                --border: #e2e8f0;
                --shadow: 0 18px 40px rgba(79, 70, 229, 0.12);
                --shadow-soft: 0 8px 20px rgba(15, 23, 42, 0.08);
                --radius: 16px;
                --radius-sm: 10px;
                --focus-ring: 0 0 0 3px rgba(79, 70, 229, 0.2);

                /* 兼容现有 JS 中的颜色变量命名 */
                --text-primary: var(--text-main);
                --text-secondary: var(--text-sub);
                --text-tertiary: var(--text-faint);
                --error: var(--danger);
                --error-subtle: var(--danger-soft);
            }

            *, *::before, *::after { box-sizing: border-box; }
            html, body { margin: 0; padding: 0; }
            html { font-size: 16px; line-height: 1.6; }
            body {
                min-height: 100vh;
                padding: 24px;
                color: var(--text-main);
                background:
                    radial-gradient(1200px 420px at 50% -140px, rgba(79, 70, 229, 0.2), transparent),
                    linear-gradient(160deg, #f7f9ff 0%, #f1f6ff 100%);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Microsoft YaHei', sans-serif;
            }
            button, input, select, textarea { font: inherit; }

            #font-container {
                position: absolute;
                width: 0;
                height: 0;
                overflow: hidden;
                visibility: hidden;
                font-family: '宋体', 'Yuniversus', 'WenJin Mincho Plane 0', 'WenJin Mincho Plane 2', 'WenJin Mincho Plane 3', 'TH-Times', 'TH-Tshyn-P0', 'TH-Tshyn-P1', 'TH-Tshyn-P2', 'TH-Tshyn-P16', 'SimSun-ExtB', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }

            .app-container { width: min(960px, 100%); margin: 0 auto; }
            .main-content { display: grid; gap: 22px; }
            .main-content > * { width: 100%; }

            .launch-container {
                min-height: 72vh;
                display: grid;
                place-content: center;
                gap: 14px;
                text-align: center;
            }
            .launch-icon { font-size: 4.75rem; line-height: 1; }
            .launch-title { margin: 0; font-size: clamp(2rem, 4vw, 2.6rem); font-weight: 750; letter-spacing: 0.02em; }
            .launch-subtitle { margin: 0 0 18px; color: var(--text-sub); }
            .launch-select input[type="file"] { display: none; }
            .file-label {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 12px 30px;
                border-radius: 999px;
                background: linear-gradient(135deg, var(--primary), var(--primary-strong));
                color: #fff;
                font-weight: 650;
                letter-spacing: 0.02em;
                cursor: pointer;
                box-shadow: var(--shadow-soft);
                transition: transform 0.2s ease, box-shadow 0.2s ease;
            }
            .file-label:hover { transform: translateY(-1px); box-shadow: 0 12px 24px rgba(79, 70, 229, 0.26); }

            .header { text-align: center; margin-bottom: 16px; }
            .logo { margin: 0 0 12px; font-size: clamp(1.75rem, 3vw, 2.2rem); font-weight: 760; letter-spacing: 0.01em; }

            .version-info-bar {
                display: inline-flex;
                align-items: center;
                padding: 9px 16px;
                border: 1px solid rgba(79, 70, 229, 0.12);
                border-radius: 999px;
                background: rgba(255, 255, 255, 0.78);
                backdrop-filter: blur(6px);
                box-shadow: var(--shadow-soft);
            }
            .version-item { display: inline-flex; gap: 6px; align-items: center; padding: 0 8px; }
            .version-label { color: var(--text-faint); font-size: 0.74rem; font-weight: 650; text-transform: uppercase; }
            .version-value { color: var(--text-sub); font-size: 0.86rem; font-weight: 650; }
            .version-divider { width: 1px; height: 15px; background: var(--border); }

            .nav-tabs {
                margin-bottom: 20px;
                padding: 12px;
                display: grid;
                gap: 10px;
                border: 1px solid rgba(79, 70, 229, 0.12);
                border-radius: var(--radius);
                background: rgba(255, 255, 255, 0.86);
                backdrop-filter: blur(6px);
                box-shadow: var(--shadow-soft);
            }
            .group-nav {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                justify-content: center;
                gap: 8px;
                padding-bottom: 10px;
                border-bottom: 1px solid var(--border);
            }
            .tab-container {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }
            .nav-tabs.is-free-mode .group-nav {
                padding-bottom: 0;
                border-bottom: none;
                justify-content: center;
            }
            .nav-tabs.is-free-mode .tab-container { display: none; }
            .nav-tabs.is-free-mode .group-tab { opacity: 0.72; }
            .nav-tabs.is-free-mode .free-tab { opacity: 1; }

            .group-tab, .tab {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                border: none;
                border-radius: 999px;
                padding: 8px 16px;
                background: transparent;
                color: var(--text-sub);
                font-size: 0.87rem;
                font-weight: 650;
                cursor: pointer;
                transition: all 0.18s ease;
            }
            .group-tab:hover, .tab:hover {
                color: var(--primary);
                background: var(--primary-soft);
            }
            .group-tab.active, .tab.active {
                color: #fff;
                background: linear-gradient(135deg, var(--primary), var(--primary-strong));
                box-shadow: 0 6px 14px rgba(79, 70, 229, 0.28);
            }
            .group-tab:focus-visible, .tab:focus-visible, .file-label:focus-visible {
                outline: none;
                box-shadow: var(--focus-ring);
            }
            .free-tab {
                color: var(--primary-strong);
                background: rgba(79, 70, 229, 0.08);
            }
            .free-tab::before {
                content: "";
                width: 6px;
                height: 6px;
                margin-right: 8px;
                border-radius: 999px;
                background: currentColor;
                opacity: 0.65;
            }
            .free-tab.active::before { opacity: 1; }

            .card {
                padding: 22px;
                border: 1px solid rgba(79, 70, 229, 0.1);
                border-radius: var(--radius);
                background: linear-gradient(180deg, #ffffff 0%, #fcfdff 100%);
                box-shadow: var(--shadow);
            }
            .practice-card { display: grid; gap: 18px; }

            .settings-bar {
                display: flex;
                flex-wrap: wrap;
                gap: 12px 20px;
                align-items: center;
                justify-content: center;
                padding-bottom: 6px;
            }
            .setting-group { display: inline-flex; align-items: center; gap: 8px; }
            .setting-group label { font-size: 0.88rem; color: var(--text-sub); font-weight: 650; }

            .radio-group { display: flex; flex-wrap: wrap; gap: 14px; }
            .radio-group label, .checkbox-label {
                display: inline-flex;
                align-items: center;
                gap: 7px;
                font-size: 0.88rem;
                color: var(--text-sub);
                cursor: pointer;
            }
            .checkbox-label { font-weight: 650; }
            .radio-group input[type="radio"], .checkbox-label input[type="checkbox"] {
                width: 16px;
                height: 16px;
                margin: 0;
                accent-color: var(--primary);
                cursor: pointer;
            }

            .text-select, .number-input {
                border: 1px solid var(--border);
                border-radius: 999px;
                background: #fff;
                color: var(--text-main);
                transition: border-color 0.16s ease, box-shadow 0.16s ease;
            }
            .text-select {
                min-width: 240px;
                padding: 8px 34px 8px 12px;
                appearance: none;
                -webkit-appearance: none;
                -moz-appearance: none;
                background-image:
                    linear-gradient(45deg, transparent 50%, var(--text-sub) 50%),
                    linear-gradient(135deg, var(--text-sub) 50%, transparent 50%);
                background-position:
                    calc(100% - 17px) calc(50% - 2px),
                    calc(100% - 12px) calc(50% - 2px);
                background-size: 5px 5px, 5px 5px;
                background-repeat: no-repeat;
            }
            .text-select:hover {
                border-color: rgba(79, 70, 229, 0.4);
                box-shadow: 0 4px 10px rgba(79, 70, 229, 0.08);
            }
            .text-select option {
                color: var(--text-main);
                background: #fff;
                padding: 6px 10px;
            }
            .text-select option:checked {
                color: var(--primary-strong);
                background: var(--primary-soft);
                font-weight: 700;
            }
            .number-input { width: 82px; padding: 8px 10px; text-align: center; font-weight: 600; }
            .action-button {
                border: none;
                border-radius: 999px;
                padding: 8px 16px;
                background: linear-gradient(135deg, var(--primary), var(--primary-strong));
                color: #fff;
                font-weight: 650;
                cursor: pointer;
                transition: transform 0.15s ease, opacity 0.15s ease, box-shadow 0.15s ease;
                box-shadow: 0 8px 16px rgba(79, 70, 229, 0.25);
            }
            .action-button:hover { transform: translateY(-1px); }
            .action-button:disabled {
                cursor: not-allowed;
                opacity: 0.55;
                box-shadow: none;
                transform: none;
            }
            .text-select:focus, .number-input:focus, #userInput:focus, .free-input:focus, .action-button:focus-visible {
                border-color: var(--primary);
                box-shadow: var(--focus-ring);
                outline: none;
            }

            .stats-bar {
                display: grid;
                gap: 10px;
                grid-template-columns: repeat(auto-fit, minmax(145px, 1fr));
                padding: 12px 14px;
                border-radius: 12px;
                background: linear-gradient(120deg, rgba(79, 70, 229, 0.12), rgba(6, 182, 212, 0.1));
                border: 1px solid rgba(79, 70, 229, 0.12);
                color: var(--primary-strong);
                font-size: 0.93rem;
                font-weight: 700;
            }
            .stats-bar span {
                text-align: center;
                padding: 2px 6px;
            }

            .content-area {
                display: grid;
                gap: 18px;
                width: 100%;
                justify-items: center;
                align-items: start;
            }

            .display-area {
                width: 100%;
                min-height: 280px;
                padding: 28px;
                border-radius: 14px;
                background: linear-gradient(180deg, #f8faff 0%, #f3f6ff 100%);
                border: 1px solid rgba(79, 70, 229, 0.1);
                font-size: 2.15rem;
                font-weight: 650;
                line-height: 1.95;
                text-align: center;
                letter-spacing: 0.08em;
                word-break: keep-all;
            }
            .display-area span {
                display: inline-block;
                margin: 4px 9px;
                padding: 6px 12px;
                border-radius: 8px;
                transition: background-color 0.2s ease, color 0.2s ease;
            }
            .free-display-area {
                min-height: 280px;
                font-size: 1.95rem;
                line-height: 1.7;
                text-align: left;
                word-break: break-word;
                overflow-wrap: anywhere;
            }
            .free-display-area span { margin: 0; padding: 0; display: inline; color: var(--text-tertiary); }
            .free-display-area span.error { color: var(--error); background: var(--error-subtle); border-radius: 4px; }
            .free-placeholder {
                width: 100%;
                text-align: center;
                color: var(--text-sub);
                font-size: 1rem;
                letter-spacing: 0;
                padding: 40px 12px;
            }

            #userInput {
                width: min(420px, 100%);
                justify-self: center;
                margin: 0 auto;
                padding: 14px 20px;
                border: 1px solid rgba(79, 70, 229, 0.18);
                border-radius: 999px;
                background: #fff;
                color: var(--text-main);
                text-align: center;
                font-size: 1.26rem;
                font-weight: 700;
                letter-spacing: 0.16em;
                caret-color: transparent;
                box-shadow: 0 8px 18px rgba(79, 70, 229, 0.12);
                transition: border-color 0.16s ease, box-shadow 0.16s ease, transform 0.16s ease;
            }
            #userInput:focus {
                transform: translateY(-1px);
                box-shadow: 0 12px 24px rgba(79, 70, 229, 0.18);
            }
            #userInput:disabled { opacity: 0.55; cursor: not-allowed; }

            .free-input {
                width: 100%;
                min-height: 185px;
                padding: 12px 14px;
                border: 1px solid rgba(79, 70, 229, 0.18);
                border-radius: 12px;
                background: #fff;
                color: var(--text-main);
                line-height: 1.7;
                font-size: 1.35rem;
                resize: vertical;
                transition: border-color 0.16s ease, box-shadow 0.16s ease;
            }
            .free-input::placeholder { color: var(--text-faint); }
            #freeUserInput {
                justify-self: stretch;
                width: 100%;
                border-radius: 12px;
                background: rgba(255, 255, 255, 0.9);
            }
            #freeUserInput:disabled {
                opacity: 0.6;
                cursor: not-allowed;
            }

            .help-block {
                margin-bottom: 14px;
                padding: 14px 16px;
                border-radius: 12px;
                border: 1px solid rgba(79, 70, 229, 0.1);
                background: linear-gradient(180deg, #fafcff 0%, #f5f8ff 100%);
            }
            .help-block h3 { margin: 0 0 8px; font-size: 1rem; }
            .help-block p { margin: 0 0 10px; color: var(--text-sub); font-size: 0.9rem; }
            .help-items { display: grid; gap: 8px; }
            .help-items code {
                display: inline-flex;
                align-self: flex-start;
                padding: 4px 9px;
                border-radius: 8px;
                background: var(--primary-soft);
                color: var(--primary-strong);
                font-weight: 700;
            }

            @media (max-width: 640px) {
                body { padding: 14px; }
                .nav-tabs { padding: 10px; }
                .card { padding: 16px; }
                .settings-bar { flex-direction: column; align-items: flex-start; }
                .radio-group { width: 100%; }
                .free-tab { margin-left: 0; }
                .display-area { padding: 18px; font-size: 1.65rem; }
                .free-display-area { font-size: 1.65rem; }
                #userInput { width: 100%; font-size: 1.12rem; }
                .stats-bar { grid-template-columns: 1fr; }
            }
        </style>


</head>

<body>
    <div id="font-container" aria-hidden="true"></div>
    <div class="app-container"></div>
</body>

</html>
