<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>输入法练习工具</title>
    <script>
        const TOML=function(){"use strict";let e="",t=0;function i(e,t=0){let i;for(;(i=e[t++])&&(" "==i||"\t"==i||"\r"==i););return t-1}function n(e){switch(e[0]){case void 0:return"";case'"':return function(e){let t,i=0,n="";for(;t=e.indexOf("\\",i)+1;){switch(n+=e.slice(i,t-1),e[t]){case"\\":n+="\\";break;case'"':n+='"';break;case"\r":"\n"==e[t+1]&&t++;case"\n":break;case"b":n+="\b";break;case"t":n+="\t";break;case"n":n+="\n";break;case"f":n+="\f";break;case"r":n+="\r";break;case"u":n+=String.fromCharCode(parseInt(e.substr(t+1,4),16)),t+=4;break;case"U":n+=String.fromCharCode(parseInt(e.substr(t+1,8),16)),t+=8;break;default:throw r(e[t])}i=t+1}return n+e.slice(i)}(e.slice(1,-1));case"'":return e.slice(1,-1);case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"+":case"-":case".":let t=e;if(-1!=t.indexOf("_")&&(t=t.replace(/_/g,"")),!isNaN(t))return+t;if("-"==e[4]&&"-"==e[7]){let t=new Date(e);if("Invalid Date"!=t.toString())return t}else if(":"==e[2]&&":"==e[5]&&e.length>=7){let t=new Date("0000-01-01T"+e+"Z");if("Invalid Date"!=t.toString())return t}return e}switch(e){case"true":return!0;case"false":return!1;case"nan":case"NaN":return!1;case"null":return null;case"inf":case"+inf":case"Infinity":case"+Infinity":return 1/0;case"-inf":case"-Infinity":return-1/0}return e}function r(i){let n=function(){let i=e[t],n=t;"\n"==i&&n--;let r=1,s=e.lastIndexOf("\n",n),a=e.indexOf("\n",n);-1==a&&(a=1/0);","!=i&&"\n"!=i||(n=s+1);if(-1==s)return{line:r,column:n+1,position:n,lineContent:e.slice(0,a).trim()};const c=n-s+1,o=e.slice(s+1,a).trim();r++;for(;-1!=(s=e.lastIndexOf("\n",s-1));)r++;return{line:r,column:c,position:n,lineContent:o}}(),r=String(n.line);return i+="\n"+r+" |  "+n.lineContent+"\n",i+=" ".repeat(r.length+n.column+2)+"^",SyntaxError(i)}function s(e,i=0,n=!1){let a,c=e[i],o=c,f=c,l=!0,u=!1;switch(c){case'"':case"'":if(a=i+1,n&&e[i+1]==c&&e[i+2]==c?(f=c+c+c,a+=2):u=!0,"'"==c)a=e.indexOf(f,a)+1;else for(;a=e.indexOf(f,a)+1;){let t=!0,i=a-1;for(;"\\"==e[--i];)t=!t;if(t)break}if(!a)throw r("Missing "+f+" closer");if(c!=f)a+=2;else if(u){let n=e.indexOf("\n",i+1)+1;if(n&&n<a)throw t=n-2,r("Forbidden end-of-line character in single-line string")}return a;case"(":f=")";break;case"{":f="}";break;case"[":f="]";break;case"<":f=">";break;default:l=!1}let h=0;for(;c=e[++i];)if(c==f){if(0==h)return i+1;h--}else if('"'==c||"'"==c){i=s(e,i,n)-1}else l&&c==o&&h++;throw r("Missing "+f)}function a(e){"string"!=typeof e&&(e=String(e));let t,i,n=-1,a="",c=[];for(;i=e[++n];)switch(i){case".":if(!a)throw r('Unexpected "."');c.push(a),a="";continue;case'"':case"'":if(t=s(e,n),t==n+2)throw r("Empty string key");a+=e.slice(n+1,t-1),n=t-1;continue;default:a+=i}return a&&c.push(a),c}function c(e,t=[]){const i=t.pop();for(let i of t){if("object"!=typeof e){throw r('["'+t.slice(0,t.indexOf(i)+1).join('"].["')+'"]'+" must be an object")}void 0===e[i]&&(e[i]={}),(e=e[i])instanceof Array&&(e=e[e.length-1])}return[e,i]}class o{constructor(){this.root={},this.data=this.root,this.inlineScopeList=[]}get isRoot(){return this.data==this.root}set(e,t){let[i,n]=c(this.data,a(e));if("string"==typeof i)throw"Wtf the scope is a string. Please report the bug";if(n in i)throw r(`Re-writing the key '${e}'`);return i[n]=t,t}push(e){if(!(this.data instanceof Array)){if(!this.isRoot)throw r("Missing key");this.data=Object.assign([],this.data),this.root=this.data}return this.data.push(e),this}use(e){return this.data=function(e,t=[]){for(let i of t){if(void 0===e)e=lastData[lastElt]={};else if("object"!=typeof e){throw r('["'+t.slice(0,t.indexOf(i)+1).join('"].["')+'"]'+" must be an object")}void 0===e[i]&&(e[i]={}),(e=e[i])instanceof Array&&(e=e[e.length-1])}return e}(this.root,a(e)),this}useArray(e){let[t,i]=c(this.root,a(e));return this.data={},void 0===t[i]&&(t[i]=[]),t[i].push(this.data),this}enter(e,t){return this.inlineScopeList.push(this.data),this.set(e,t),this.data=t,this}enterArray(e){return this.inlineScopeList.push(this.data),this.push(e),this.data=e,this}exit(){return this.data=this.inlineScopeList.pop(),this}}function f(a){"string"!=typeof a&&(a=String(a));const c=new o,f=[];e=a,t=0;let l,u,h="",d="",p=e[0],w=!0;const g=()=>{if(h=h.trimEnd(),w)h&&c.push(n(h));else{if(!h)throw r("Expected key before =");if(!d)throw r("Expected value after =");c.set(h,n(d.trimEnd()))}h="",d="",w=!0};do{switch(p){case" ":w?h&&(h+=p):d&&(d+=p);case"\t":case"\r":continue;case"#":t=e.indexOf("\n",t+1)-1,-2==t&&(t=1/0);continue;case'"':case"'":if(!w&&d){d+=p;continue}let n=e[t+1]==p&&e[t+2]==p;if(l=s(e,t,!0),w){if(h)throw r("Unexpected "+p);h+=n?e.slice(t+2,l-2):e.slice(t,l),t=l}else d=e.slice(t,l),t=l,n&&(d=d.slice(2,-2),"\n"==d[1]?d=d[0]+d.slice(2):"\r"==d[1]&&"\n"==d[2]&&(d=d[0]+d.slice(3)));if(t=i(e,t),p=e[t],p&&","!=p&&"\n"!=p&&"#"!=p&&"}"!=p&&"]"!=p&&"="!=p)throw r("Unexpected character after end of string");t--;continue;case"\n":case",":case void 0:g();continue;case"[":case"{":if(u="["==p?"]":"}",w&&!f.length){if(h)throw r("Unexpected "+p);if(l=s(e,t),"["==p&&"["==e[t+1]){if("]"!=e[l-2])throw r("Missing ]]");c.useArray(e.slice(t+2,l-2))}else c.use(e.slice(t+1,l-1));t=l}else if(w){if(h)throw r("Unexpected "+p);c.enterArray("["==p?[]:{}),f.push(u)}else{if(d)throw r("Unexpected "+p);c.enter(h.trimEnd(),"["==p?[]:{}),f.push(u),h="",w=!0}continue;case"]":case"}":if(h&&g(),f.pop()!=p)throw r("Unexpected "+p);if(c.exit(),t=i(e,t+1),p=e[t],p&&","!=p&&"\n"!=p&&"#"!=p&&"}"!=p&&"]"!=p)throw r("Unexpected character after end of scope");t--;continue;case"=":if(!w)throw r("Unexpected "+p);if(!h)throw r("Missing key before "+p);w=!1;continue;default:w?h+=p:d+=p}}while((p=e[++t])||h);if(f.length)throw r("Missing "+f.pop());return c.root}let l=null,u=null;function h(){let e="";for(let t of arguments)e+="string"==typeof t?t:t[0];return f(e)}return h.parse=f,h.parseFile=async function(e){if(l||(l=require("fs")),!u){const{promisify:e}=require("util");u=e(l.readFile)}return f(await u(e))},h.parseFileSync=function(e){return l||(l=require("fs")),f(l.readFileSync(e))},h}();

        const config = {}
        const appVersion = "1.0.0"

        let speedTimer = null
        let wordCount = 0
        let startTime = 0
        let curInputMax = 0
        let curInputIndex = 0
        let curTab = 0
        let totalWords = []
        let totalIndex = 0
        let inputTimer = null

        let rawArea = null
        let rawAreaFonts = null
        let userInput = null
        let speedLabel = null
        let progressLabel = null

        const onConfigSelected = async (e) => {
            const file = e.target.files[0]
            if (!file) return
            try {
                const text = await file.text()
                const newConfig = TOML.parse(text)
                Object.assign(config, newConfig)
                // 设置标题和版本
                document.title = config.name || '输入法练习工具'
                // 恢复主界面结构
                document.querySelector('.app-container').innerHTML = `<header class="header">
                    <h1 class="logo">${config.name || '输入法练习工具'}</h1>
                    <div class="version-info-bar">
                        <span class="version-item"><span class="version-label">应用</span><span class="version-value">${appVersion}</span></span>
                        <span class="version-divider"></span>
                        <span class="version-item"><span class="version-label">输入法</span><span class="version-value">${config.version || '-'}</span></span>
                        <span class="version-divider"></span>
                        <span class="version-item"><span class="version-label">配置</span><span class="version-value">${config.config_version || '-'}</span></span>
                    </div>
                </header>
                <nav class="nav-tabs"></nav>
                <main></main>`
                // 重置变量
                speedTimer = null; wordCount = 0; startTime = 0
                curInputMax = 0; curInputIndex = 0; curTab = 0
                totalWords = []; totalIndex = 0
                initTabs()
                initKeyBindings()
                displayHelp()
                // 加载字体
                await loadFonts()
            } catch (err) {
                console.error('加载配置失败:', err, err.stack)
                alert('加载配置失败: ' + err.message + '\n请查看控制台获取详情')
            }
        }

        const initDomReferences = () => {
            rawArea = document.getElementById("rawArea")
            userInput = document.getElementById("userInput")
            speedLabel = document.getElementById("speedLabel")
            progressLabel = document.getElementById("progressLabel")
            userInput.oninput = handleInput

            const oneTimeCount = document.getElementById("oneTimeCount")
            const totalCount = document.getElementById("totalCount")
            oneTimeCount.addEventListener('change', () => startPractice(curTab))
            totalCount.addEventListener('change', () => startPractice(curTab))

            document.addEventListener('click', function (e) {
                if (userInput && document.activeElement !== userInput &&
                    e.target.id !== 'oneTimeCount' &&
                    e.target.id !== 'totalCount') {
                    userInput.focus({ preventScroll: true })
                }
            })
        }

        let compiledKeyBindings = []

        const compileKeyBindings = () => {
            compiledKeyBindings = []
            if (!config.key_bindings || !Array.isArray(config.key_bindings)) return
            for (const binding of config.key_bindings) {
                const key = binding.key.toLowerCase().replace(/\s+/g, '')
                const parts = key.split('+')
                const modifiers = parts.filter(p => ['ctrl', 'alt', 'shift', 'meta'].includes(p))
                const keyPart = parts.find(p => !['ctrl', 'alt', 'shift', 'meta'].includes(p))
                compiledKeyBindings.push({ modifiers, keyPart, command: binding.command })
            }
        }

        const initKeyBindings = () => {
            compileKeyBindings()
            document.addEventListener('keydown', (e) => {
                for (const binding of compiledKeyBindings) {
                    const ctrlMatch = binding.modifiers.includes('ctrl') ? e.ctrlKey : !e.ctrlKey
                    const altMatch = binding.modifiers.includes('alt') ? e.altKey : !e.altKey
                    const shiftMatch = binding.modifiers.includes('shift') ? e.shiftKey : !e.shiftKey
                    const metaMatch = binding.modifiers.includes('meta') ? e.metaKey : !e.metaKey
                    const keyMatch = e.key.toLowerCase() === binding.keyPart

                    if (ctrlMatch && altMatch && shiftMatch && metaMatch && keyMatch) {
                        e.preventDefault()
                        switch (binding.command) {
                            case 'tab_reload':
                                startPractice(curTab)
                                break
                        }
                        break
                    }
                }
            })
        }

        const main = () => {
            document.querySelector('.app-container').innerHTML = `<div class="launch-container">
                <div class="launch-icon">⌨️</div>
                <h1 class="launch-title">输入法练习工具</h1>
                <p class="launch-subtitle">选择配置文件开始练习</p>
                <div class="launch-select">
                    <input type="file" id="configFile" accept=".toml">
                    <label for="configFile" class="file-label">选择文件</label>
                </div>
            </div>`
            document.getElementById('configFile').addEventListener('change', onConfigSelected)
        }

        const showTemplate = (templateId) => {
            const mainEl = document.querySelector("main")
            if (templateId === "help-template") {
                mainEl.innerHTML = config.help
                return
            }
            const template = document.getElementById(templateId)
            if (!template) {
                console.error('Template not found:', templateId)
                return
            }
            const clone = template.content.cloneNode(true)

            if (templateId === "practice-template") {
                const radioGroup = clone.querySelector(".radio-group")
                if (radioGroup) {
                    radioGroup.innerHTML = ""
                    const savedIdx = getModeIndex()
                    for (let i = 0; i < modeConfigs.length; i++) {
                        const label = document.createElement("label")
                        const input = document.createElement("input")
                        input.type = "radio"
                        input.name = "radiobutton"
                        input.checked = (i === savedIdx)
                        input.onclick = () => {
                            setModeIndex(i)
                            startPractice(curTab)
                        }
                        label.appendChild(input)
                        label.appendChild(document.createTextNode(modeConfigs[i].label))
                        radioGroup.appendChild(label)
                    }
                }

                const hintCheckbox = clone.querySelector("#showHint")
                if (hintCheckbox) {
                    hintCheckbox.checked = getShowHint()
                    hintCheckbox.onchange = (e) => {
                        setShowHint(e.target.checked)
                        updatePlaceholder()
                    }
                }

                const oneTimeCountInput = clone.querySelector("#oneTimeCount")
                if (oneTimeCountInput) {
                    oneTimeCountInput.value = getOneTimeCount()
                    oneTimeCountInput.onchange = (e) => setOneTimeCount(e.target.value)
                }

                const totalCountInput = clone.querySelector("#totalCount")
                if (totalCountInput) {
                    totalCountInput.value = getTotalCount()
                    totalCountInput.onchange = (e) => setTotalCount(e.target.value)
                }
            }

            mainEl.innerHTML = ""
            mainEl.appendChild(clone)
        }

        const displayHelp = () => {
            resetTimer()
            updateTabStyles(0)
            const mainEl = document.querySelector("main")
            mainEl.innerHTML = config.help
        }

        const modeConfigs = [
            { name: "sequential", label: "顺序单次", handler: (words) => words },
            { name: "shuffled", label: "乱序单次", handler: (words) => shuffleWords(words) },
            { name: "repeated", label: "乱序重复", handler: (words) => generateRandomIndices(getSettingValue("totalCount"), words.length).map(i => words[i]) },
        ]

        const initTabs = () => {
            const nav = document.querySelector(".nav-tabs")
            nav.querySelectorAll(".tab").forEach(t => t.remove())

            config.tabs.forEach((tabConfig, i) => {
                const btn = document.createElement("button")
                btn.className = "tab"
                btn.id = `tab${i}`
                btn.textContent = tabConfig.label
                btn.onclick = () => tabConfig.type === "help" ? displayHelp() : startPractice(i)
                nav.appendChild(btn)
            })
        }

        const getModeIndex = () => parseInt(sessionStorage.getItem("radioMode") || "0")

        const setModeIndex = (idx) => sessionStorage.setItem("radioMode", idx)

        const getShowHint = () => sessionStorage.getItem("showHint") !== "false"

        const setShowHint = (val) => sessionStorage.setItem("showHint", val)

        const getOneTimeCount = () => parseInt(sessionStorage.getItem("oneTimeCount") || "30")

        const setOneTimeCount = (val) => sessionStorage.setItem("oneTimeCount", val)

        const getTotalCount = () => parseInt(sessionStorage.getItem("totalCount") || "120")

        const setTotalCount = (val) => sessionStorage.setItem("totalCount", val)

        const getCurrentWord = () => {
            if (curInputIndex >= curInputMax) return null
            return document.getElementById(`word${curInputIndex}`)
        }

        const updatePlaceholder = () => {
            const word = getCurrentWord()
            if (!word) return
            userInput.setAttribute("placeholder", getShowHint() ? word.getAttribute("key") : "")
        }

        const startPractice = (val) => {
            updateTabStyles(val)
            showTemplate("practice-template")
            initDomReferences()
            toggleInputArea(true)

            rawArea.style.fontFamily = rawAreaFonts
            userInput.removeAttribute("disabled")

            updatePlaceholder()

            userInput.focus({ preventScroll: true })
            totalIndex = 0; wordCount = 0; curTab = val
            speedLabel.textContent = "速度：0.00字/分"

            const allWords = getWordsByRange(config.tabs[val].beg, config.tabs[val].end)
            const modeIdx = getModeIndex()
            totalWords = modeConfigs[modeIdx].handler(allWords)

            loadNextBatch()
            progressLabel.textContent = `\t进度：0/${totalWords.length}字`
            resetTimer()
        }

        const updateSpeedDisplay = () => {
            speedTimer = setTimeout(updateSpeedDisplay, 500)
            if (wordCount > 0) {
                const speed = wordCount * 60 * 1000 / (new Date().getTime() - startTime)
                speedLabel.textContent = `速度：${speed.toFixed(2)}字/分`
            }
        }

        const startTimer = () => {
            if (speedTimer === null) {
                startTime = new Date().getTime()
                updateSpeedDisplay()
            }
        }

        const resetTimer = () => {
            if (speedTimer !== null) {
                clearTimeout(speedTimer)
                speedTimer = null
            }
        }

        const getWordsByRange = (beg, end) => {
            const words = []
            for (let i = beg; i < end; i++) {
                const objs = config.items[i]
                for (const key in objs) {
                    objs[key].forEach(code => words.push({ key, code }))
                }
            }
            return words
        }

        const loadNextBatch = () => {
            const lastCount = totalWords.length - totalIndex
            if (lastCount <= 0) return false

            const wordNeed = Math.min(lastCount, getSettingValue("oneTimeCount"))
            curInputMax = wordNeed; curInputIndex = 0
            clearDisplayArea()

            totalWords.slice(totalIndex, totalIndex + wordNeed).forEach((word, idx) => {
                const span = document.createElement("span")
                span.textContent = word.code
                span.setAttribute("key", word.key)
                span.id = `word${idx}`
                span.style.color = "var(--text-tertiary)"
                rawArea.appendChild(span)
            })
            totalIndex += wordNeed
            updatePlaceholder()
            return true
        }

        const getSettingValue = (id) => parseInt(document.getElementById(id).value)

        const shuffleWords = (arr) => {
            const indices = [...Array(arr.length).keys()]
            for (let i = 0; i < indices.length; i++) {
                const j = Math.floor(Math.random() * indices.length)
                    ;[indices[i], indices[j]] = [indices[j], indices[i]]
            }
            return indices.map(i => arr[i])
        }

        const generateRandomIndices = (size, max) => {
            const result = []
            for (let i = 0; i < size; i++) { result.push(Math.floor(Math.random() * max)) }
            return result
        }

        const handleInput = () => {
            if (curInputIndex >= curInputMax) return
            if (inputTimer) clearTimeout(inputTimer)

            inputTimer = setTimeout(() => {
                const word = document.getElementById(`word${curInputIndex}`)
                const key = word.getAttribute("key")
                const val = userInput.value

                if (val.length < key.length) { inputTimer = null; return }

                if (val.toLowerCase() === key) {
                    startTimer()
                    curInputIndex++; wordCount++
                    progressLabel.textContent = `\t进度：${wordCount}/${totalWords.length}字`
                    word.style.color = "var(--text-primary)"
                    userInput.value = ""
                    updatePlaceholder()
                } else {
                    word.style.color = "var(--error)"
                    userInput.value = ""
                    userInput.setAttribute("placeholder", key)
                }
                inputTimer = null

                if (curInputIndex >= curInputMax) {
                    if (!loadNextBatch()) {
                        userInput.setAttribute("disabled", "true")
                        resetTimer()
                    }
                }
            }, 50)
        }

        const updateTabStyles = (activateIdx) => {
            document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"))
            if (activateIdx !== null) {
                document.getElementById(`tab${activateIdx}`).classList.add("active")
            }
        }

        const toggleInputArea = (val) => {
            const contentCard = document.getElementById("content")
            contentCard.style.display = val ? "flex" : "none"
            userInput.value = ""
        }

        const clearDisplayArea = () => {
            rawArea.innerHTML = ''
        }

        // 字体加载功能
        const loadFonts = async () => {
            const loadedFontNames = []
            for (let i = 0; i < config.fonts.length; i++) {
                const font = config.fonts[i]
                if (!font.name) continue

                const isSystemFont = await checkSystemFont(font.name)
                if (isSystemFont) {
                    loadedFontNames.push(font.name)
                    continue
                }

                if (font.base64 && font.base64.length > 0 && font.type) {
                    if (await loadFontFromBase64(font.name, font.base64, font.type)) {
                        loadedFontNames.push(font.name)
                        continue
                    }
                }

                if (font.file && font.file.length > 0) {
                    if (await loadFontFromFile(font.name, font.file)) {
                        loadedFontNames.push(font.name)
                    }
                }
            }

            const cssFontFamily = getComputedStyle(document.getElementById("font-container")).fontFamily
            const fallbackFonts = cssFontFamily
                .split(',')
                .map(f => f.trim().replace(/^['"]|['"]$/g, ''))
                .filter(f => f && !loadedFontNames.includes(f))
                .join("', '")

            if (loadedFontNames.length > 0) {
                rawAreaFonts = "'" + loadedFontNames.join("', '") + "', '" + fallbackFonts + "'"
            } else {
                rawAreaFonts = "'" + fallbackFonts + "'"
            }
        }

        // 检查系统字体是否存在
        const checkSystemFont = (fontName) => {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas')
                const ctx = canvas.getContext('2d')
                const testString = 'mmmmmmmmmmlli'

                ctx.font = `72px "${fontName}"`
                const baselineSize = ctx.measureText(testString).width

                ctx.font = `72px sans-serif`
                const fallbackSize = ctx.measureText(testString).width

                resolve(baselineSize !== fallbackSize)
            })
        }

        // 从 base64 加载字体
        const loadFontFromBase64 = (fontName, base64, type) => {
            return new Promise((resolve) => {
                const fontUrl = `data:font/${type};base64,${base64}`
                const fontFace = new FontFace(fontName, `url(${fontUrl})`)

                fontFace.load().then((loadedFace) => {
                    document.fonts.add(loadedFace)
                    resolve(true)
                }).catch((err) => {
                    console.error(`loadFontFromBase64 failed: ${fontName}`, err)
                    resolve(false)
                })
            })
        }

        // 从本地文件加载字体
        const loadFontFromFile = (fontName, fileName) => {
            return new Promise((resolve) => {
                const fontFace = new FontFace(fontName, `url(${fileName})`)
                fontFace.load()
                    .then((loadedFace) => {
                        document.fonts.add(loadedFace)
                        resolve(true)
                    })
                    .catch((err) => {
                        console.warn(`字体加载失败（文件可能不存在）: ${fileName}`)
                        resolve(false)
                    })
            })
        }

        window.addEventListener('load', main)
    </script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-subtle: #eef2ff;
            --success: #10b981;
            --success-subtle: #d1fae5;
            --error: #ef4444;
            --error-subtle: #fee2e2;
            --warning: #f59e0b;
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-tertiary: #cbd5e1;
            --border: #e2e8f0;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.07), 0 2px 4px -1px rgba(0, 0, 0, 0.04);
            --radius: 12px;
            --radius-sm: 8px;
            --transition: 0.2s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--bg);
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 24px;
        }

        .app-container {
            width: 100%;
            max-width: 900px;
        }

        .header {
            text-align: center;
            margin-bottom: 24px;
        }

        .logo {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }

        .version-info-bar {
            display: inline-flex;
            align-items: center;
            gap: 0;
            padding: 8px 16px;
            background: var(--card-bg);
            border-radius: 20px;
            box-shadow: var(--shadow-sm);
        }

        .version-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
        }

        .version-label {
            color: var(--text-tertiary);
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .version-value {
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 600;
        }

        .version-divider {
            width: 1px;
            height: 16px;
            background: var(--border);
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 24px;
            padding: 6px;
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .tab {
            padding: 10px 18px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: all var(--transition);
        }

        .tab:hover {
            background: var(--primary-subtle);
            color: var(--primary);
        }

        .tab.active {
            background: var(--primary);
            color: white;
            box-shadow: var(--shadow-sm);
        }

        .card {
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 24px;
            margin-bottom: 20px;
        }

        .practice-card {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .practice-card .content-area {
            margin-top: 0;
        }

        .settings-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        .setting-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-group label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .spinner {
            width: 70px;
            padding: 8px 10px;
            border: 2px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            text-align: center;
            outline: none;
            transition: all var(--transition);
            color: var(--text-primary);
            font-weight: 500;
        }

        .spinner:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .radio-group {
            display: flex;
            gap: 16px;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            color: var(--text-secondary);
            transition: color var(--transition);
        }

        .radio-group label:hover {
            color: var(--text-primary);
        }

        .radio-group input[type="radio"] {
            width: 16px;
            height: 16px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
            transition: color var(--transition);
        }

        .checkbox-label:hover {
            color: var(--text-primary);
        }

        .checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .stats-bar {
            display: flex;
            gap: 24px;
            justify-content: center;
            padding: 14px 24px;
            background: var(--primary-subtle);
            border-radius: var(--radius-sm);
            font-weight: 600;
            color: var(--primary);
            font-size: 0.95rem;
        }

        .content-area {
            display: flex;
            flex-direction: column;
        }

        .display-area {
            width: 100%;
            min-height: 280px;
            padding: 28px;
            background: var(--bg);
            border-radius: var(--radius);
            font-size: 2.25rem;
            font-weight: 600;
            line-height: 2;
            outline: none;
            word-break: keep-all;
            overflow-y: visible;
            resize: none;
            letter-spacing: 0.08em;
            text-align: center;
            border: none;
        }

        .display-area span {
            display: inline-block;
            margin: 4px 10px;
            padding: 6px 14px;
            border-radius: var(--radius-sm);
            transition: all var(--transition);
        }

        .display-area span.completed {
            color: var(--success);
            background: var(--success-subtle);
        }

        .display-area span.current {
            color: var(--warning);
            background: var(--warning-subtle);
            transform: scale(1.08);
        }

        .display-area span.error {
            color: var(--error);
            background: var(--error-subtle);
        }

        .input-area {
            margin-top: 24px;
            display: flex;
            justify-content: center;
        }

        #userInput {
            width: 100%;
            max-width: 320px;
            padding: 16px 24px;
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            outline: none;
            transition: all var(--transition);
            letter-spacing: 0.15em;
            color: var(--text-primary);
            caret-color: transparent;
        }

        #userInput:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.12);
        }

        #userInput:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #font-container {
            font-family: '宋体', 'Yuniversus', 'WenJin Mincho Plane 0', 'WenJin Mincho Plane 2', 'WenJin Mincho Plane 3', 'TH-Times', 'TH-Tshyn-P0', 'TH-Tshyn-P1', 'TH-Tshyn-P2', 'TH-Tshyn-P16', 'SimSun-ExtB', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .help-block {
            padding: 16px 20px;
            margin-bottom: 16px;
            background: var(--bg);
            border-radius: var(--radius-sm);
        }

        .help-block h3 {
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .help-block p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 12px;
        }

        .help-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .help-items code {
            display: inline-block;
            background: var(--primary-subtle);
            color: var(--primary);
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 600;
        }

        @media (max-width: 640px) {
            body {
                padding: 16px;
            }

            .nav-tabs {
                gap: 6px;
                padding: 4px;
            }

            .tab {
                padding: 8px 14px;
                font-size: 0.85rem;
            }

            .card {
                padding: 20px;
            }

            .settings-bar {
                flex-direction: column;
                gap: 16px;
            }

            .display-area {
                font-size: 1.75rem;
                padding: 20px;
            }

            .stats-bar {
                flex-direction: column;
                gap: 12px;
                text-align: center;
            }
        }

        .launch-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 70vh;
            gap: 16px;
            text-align: center;
        }

        .launch-icon {
            font-size: 5rem;
            margin-bottom: 8px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .launch-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }

        .launch-subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin: 0 0 24px 0;
        }

        .launch-select {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .launch-select input[type="file"] {
            display: none;
        }

        .file-label {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 14px 32px;
            font-size: 1.1rem;
            font-weight: 500;
            color: white;
            background: linear-gradient(135deg, var(--primary) 0%, #6366f1 100%);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 14px rgba(99, 102, 241, 0.4);
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.5);
        }

        .file-label:active {
            transform: translateY(0);
        }
    </style>
</head>

<body>
    <div id="font-container"></div>
    <div class="app-container"></div>
    <template id="practice-template">
        <div class="card practice-card">
            <div class="settings-bar">
                <div class="setting-group">
                    <label>单次字数</label>
                    <input id="oneTimeCount" class="spinner" type="number" min="10" max="500" value="30">
                </div>
                <div class="setting-group">
                    <label>练习总数</label>
                    <input id="totalCount" class="spinner" type="number" min="10" max="500" value="120">
                </div>
                <div class="setting-group checkbox-group">
                    <label class="checkbox-label">
                        <input id="showHint" type="checkbox">
                        <span>显示提示</span>
                    </label>
                </div>
                <div class="radio-group"></div>
            </div>
            <div class="stats-bar">
                <span id="progressLabel"></span>
                <span id="speedLabel"></span>
            </div>
            <div class="content-area" id="content">
                <div class="display-area" id="rawArea"></div>
                <div class="input-area">
                    <input id="userInput">
                </div>
            </div>
        </div>
    </template>
</body>

</html>
