<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>输入法练习工具</title>
    <script>
        // ============================================
        // 工具库 - TOML解析器（保持不变）
        // ============================================
        const TOML=function(){"use strict";let e="",t=0;function i(e,t=0){let i;for(;(i=e[t++])&&(" "==i||"\t"==i||"\r"==i););return t-1}function n(e){switch(e[0]){case void 0:return"";case'"':return function(e){let t,i=0,n="";for(;t=e.indexOf("\\",i)+1;){switch(n+=e.slice(i,t-1),e[t]){case"\\":n+="\\";break;case'"':n+='"';break;case"\r":"\n"==e[t+1]&&t++;case"\n":break;case"b":n+="\b";break;case"t":n+="\t";break;case"n":n+="\n";break;case"f":n+="\f";break;case"r":n+="\r";break;case"u":n+=String.fromCharCode(parseInt(e.substr(t+1,4),16)),t+=4;break;case"U":n+=String.fromCharCode(parseInt(e.substr(t+1,8),16)),t+=8;break;default:throw r(e[t])}i=t+1}return n+e.slice(i)}(e.slice(1,-1));case"'":return e.slice(1,-1);case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"+":case"-":case".":let t=e;if(-1!=t.indexOf("_")&&(t=t.replace(/_/g,"")),!isNaN(t))return+t;if("-"==e[4]&&"-"==e[7]){let t=new Date(e);if("Invalid Date"!=t.toString())return t}else if(":"==e[2]&&":"==e[5]&&e.length>=7){let t=new Date("0000-01-01T"+e+"Z");if("Invalid Date"!=t.toString())return t}return e}switch(e){case"true":return!0;case"false":return!1;case"nan":case"NaN":return!1;case"null":return null;case"inf":case"+inf":case"Infinity":case"+Infinity":return 1/0;case"-inf":case"-Infinity":return-1/0}return e}function r(i){let n=function(){let i=e[t],n=t;"\n"==i&&n--;let r=1,s=e.lastIndexOf("\n",n),a=e.indexOf("\n",n);-1==a&&(a=1/0);","!=i&&"\n"!=i||(n=s+1);if(-1==s)return{line:r,column:n+1,position:n,lineContent:e.slice(0,a).trim()};const c=n-s+1,o=e.slice(s+1,a).trim();r++;for(;-1!=(s=e.lastIndexOf("\n",s-1));)r++;return{line:r,column:c,position:n,lineContent:o}}(),r=String(n.line);return i+="\n"+r+" |  "+n.lineContent+"\n",i+=" ".repeat(r.length+n.column+2)+"^",SyntaxError(i)}function s(e,i=0,n=!1){let a,c=e[i],o=c,f=c,l=!0,u=!1;switch(c){case'"':case"'":if(a=i+1,n&&e[i+1]==c&&e[i+2]==c?(f=c+c+c,a+=2):u=!0,"'"==c)a=e.indexOf(f,a)+1;else for(;a=e.indexOf(f,a)+1;){let t=!0,i=a-1;for(;"\\"==e[--i];)t=!t;if(t)break}if(!a)throw r("Missing "+f+" closer");if(c!=f)a+=2;else if(u){let n=e.indexOf("\n",i+1)+1;if(n&&n<a)throw t=n-2,r("Forbidden end-of-line character in single-line string")}return a;case"(":f=")";break;case"{":f="}";break;case"[":f="]";break;case"<":f=">";break;default:l=!1}let h=0;for(;c=e[++i];)if(c==f){if(0==h)return i+1;h--}else if('"'==c||"'"==c){i=s(e,i,n)-1}else l&&c==o&&h++;throw r("Missing "+f)}function a(e){"string"!=typeof e&&(e=String(e));let t,i,n=-1,a="",c=[];for(;i=e[++n];)switch(i){case".":if(!a)throw r('Unexpected "."');c.push(a),a="";continue;case'"':case"'":if(t=s(e,n),t==n+2)throw r("Empty string key");a+=e.slice(n+1,t-1),n=t-1;continue;default:a+=i}return a&&c.push(a),c}function c(e,t=[]){const i=t.pop();for(let i of t){if("object"!=typeof e){throw r('["'+t.slice(0,t.indexOf(i)+1).join('"].["')+'"]'+" must be an object")}void 0===e[i]&&(e[i]={}),(e=e[i])instanceof Array&&(e=e[e.length-1])}return[e,i]}class o{constructor(){this.root={},this.data=this.root,this.inlineScopeList=[]}get isRoot(){return this.data==this.root}set(e,t){let[i,n]=c(this.data,a(e));if("string"==typeof i)throw"Wtf the scope is a string. Please report the bug";if(n in i)throw r(`Re-writing the key '${e}'`);return i[n]=t,t}push(e){if(!(this.data instanceof Array)){if(!this.isRoot)throw r("Missing key");this.data=Object.assign([],this.data),this.root=this.data}return this.data.push(e),this}use(e){return this.data=function(e,t=[]){for(let i of t){if(void 0===e)e=lastData[lastElt]={};else if("object"!=typeof e){throw r('["'+t.slice(0,t.indexOf(i)+1).join('"].["')+'"]'+" must be an object")}void 0===e[i]&&(e[i]={}),(e=e[i])instanceof Array&&(e=e[e.length-1])}return e}(this.root,a(e)),this}useArray(e){let[t,i]=c(this.root,a(e));return this.data={},void 0===t[i]&&(t[i]=[]),t[i].push(this.data),this}enter(e,t){return this.inlineScopeList.push(this.data),this.set(e,t),this.data=t,this}enterArray(e){return this.inlineScopeList.push(this.data),this.push(e),this.data=e,this}exit(){return this.data=this.inlineScopeList.pop(),this}}function f(a){"string"!=typeof a&&(a=String(a));const c=new o,f=[];e=a,t=0;let l,u,h="",d="",p=e[0],w=!0;const g=()=>{if(h=h.trimEnd(),w)h&&c.push(n(h));else{if(!h)throw r("Expected key before =");if(!d)throw r("Expected value after =");c.set(h,n(d.trimEnd()))}h="",d="",w=!0};do{switch(p){case" ":w?h&&(h+=p):d&&(d+=p);case"\t":case"\r":continue;case"#":t=e.indexOf("\n",t+1)-1,-2==t&&(t=1/0);continue;case'"':case"'":if(!w&&d){d+=p;continue}let n=e[t+1]==p&&e[t+2]==p;if(l=s(e,t,!0),w){if(h)throw r("Unexpected "+p);h+=n?e.slice(t+2,l-2):e.slice(t,l),t=l}else d=e.slice(t,l),t=l,n&&(d=d.slice(2,-2),"\n"==d[1]?d=d[0]+d.slice(2):"\r"==d[1]&&"\n"==d[2]&&(d=d[0]+d.slice(3)));if(t=i(e,t),p=e[t],p&&","!=p&&"\n"!=p&&"#"!=p&&"}"!=p&&"]"!=p&&"="!=p)throw r("Unexpected character after end of string");t--;continue;case"\n":case",":case void 0:g();continue;case"[":case"{":if(u="["==p?"]":"}",w&&!f.length){if(h)throw r("Unexpected "+p);if(l=s(e,t),"["==p&&"["==e[t+1]){if("]"!=e[l-2])throw r("Missing ]]");c.useArray(e.slice(t+2,l-2))}else c.use(e.slice(t+1,l-1));t=l}else if(w){if(h)throw r("Unexpected "+p);c.enterArray("["==p?[]:{}),f.push(u)}else{if(d)throw r("Unexpected "+p);c.enter(h.trimEnd(),"["==p?[]:{}),f.push(u),h="",w=!0}continue;case"]":case"}":if(h&&g(),f.pop()!=p)throw r("Unexpected "+p);if(c.exit(),t=i(e,t+1),p=e[t],p&&","!=p&&"\n"!=p&&"#"!=p&&"}"!=p&&"]"!=p)throw r("Unexpected character after end of scope");t--;continue;case"=":if(!w)throw r("Unexpected "+p);if(!h)throw r("Missing key before "+p);w=!1;continue;default:w?h+=p:d+=p}}while((p=e[++t])||h);if(f.length)throw r("Missing "+f.pop());return c.root}let l=null,u=null;function h(){let e="";for(let t of arguments)e+="string"==typeof t?t:t[0];return f(e)}return h.parse=f,h.parseFile=async function(e){if(l||(l=require("fs")),!u){const{promisify:e}=require("util");u=e(l.readFile)}return f(await u(e))},h.parseFileSync=function(e){return l||(l=require("fs")),f(l.readFileSync(e))},h}();

        // ============================================
        // 字体加载模块
        // ============================================
        const FontLoader = (() => {
            const FONT_LOAD_TIMEOUT = 5000

            // 检查系统字体是否存在
            const checkSystemFont = (fontName) => {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas')
                    const ctx = canvas.getContext('2d')
                    const testString = 'mmmmmmmmmmlli'

                    ctx.font = `72px "${fontName}"`
                    const baselineSize = ctx.measureText(testString).width

                    ctx.font = `72px sans-serif`
                    const fallbackSize = ctx.measureText(testString).width

                    resolve(baselineSize !== fallbackSize)
                })
            }

            // 通用字体加载函数（带超时处理）
            const loadFontWithSource = (fontName, fontSource, onError) => {
                return new Promise((resolve) => {
                    const fontFace = new FontFace(fontName, fontSource)
                    const timeoutId = setTimeout(() => {
                        console.warn(`字体加载超时: ${fontName}`)
                        resolve(false)
                    }, FONT_LOAD_TIMEOUT)

                    fontFace.load().then((loadedFace) => {
                        clearTimeout(timeoutId)
                        document.fonts.add(loadedFace)
                        resolve(true)
                    }).catch((err) => {
                        clearTimeout(timeoutId)
                        onError?.(err) || console.warn(`字体加载失败: ${fontName}`)
                        resolve(false)
                    })
                })
            }

            // 加载单个字体
            const loadFont = async (font) => {
                if (!font.name) return null

                const isSystemFont = await checkSystemFont(font.name)
                if (isSystemFont) return font.name

                if (font.base64?.length > 0 && font.type) {
                    const url = `data:font/${font.type};base64,${font.base64}`
                    if (await loadFontWithSource(font.name, `url(${url})`)) return font.name
                }

                if (font.file?.length > 0) {
                    if (await loadFontWithSource(font.name, `url(${font.file})`)) return font.name
                }

                return null
            }

            // 加载所有字体
            const loadAll = async (fonts) => {
                if (!fonts || !Array.isArray(fonts)) return null

                const loadedFontNames = []
                for (const font of fonts) {
                    const result = await loadFont(font)
                    if (result) loadedFontNames.push(result)
                }

                // 构建字体栈
                const fontContainer = document.getElementById("font-container")
                const cssFontFamily = getComputedStyle(fontContainer).fontFamily
                const fallbackFonts = cssFontFamily
                    .split(',')
                    .map(f => f.trim().replace(/^['"]|['"]$/g, ''))
                    .filter(f => f && !loadedFontNames.includes(f))
                    .join("', '")

                if (loadedFontNames.length > 0) {
                    return "'" + loadedFontNames.join("', '") + "', '" + fallbackFonts + "'"
                }
                return "'" + fallbackFonts + "'"
            }

            return { loadAll }
        })()

        // ============================================
        // 配置缓存模块
        // ============================================
        const ConfigCache = (() => {
            let lastConfigPath = null
            let lastConfigContent = null

            const isSameConfig = (path, content) => {
                return lastConfigPath === path && lastConfigContent === content
            }

            const set = (path, content) => {
                lastConfigPath = path
                lastConfigContent = content
            }

            const clear = () => {
                lastConfigPath = null
                lastConfigContent = null
            }

            return { isSameConfig, set, clear }
        })()

        // ============================================
        // 指标跟踪模块（统一管理打字速度、击键速度、键准）
        // ============================================
        const MetricsTracker = (() => {
            let updateTimer = null
            let startTime = 0
            let wordCount = 0
            let totalKeystrokes = 0
            let errorKeystrokes = 0
            let currentUpdateFn = null // 当前使用的更新函数

            // 重置所有指标
            const reset = () => {
                if (updateTimer) {
                    clearTimeout(updateTimer)
                    updateTimer = null
                }
                startTime = 0
                wordCount = 0
                totalKeystrokes = 0
                errorKeystrokes = 0
                currentUpdateFn = null
            }

            // 开始计时（并指定更新函数）
            const start = (updateFn) => {
                if (startTime === 0) {
                    startTime = new Date().getTime()
                    currentUpdateFn = updateFn
                    updateMetrics()
                }
            }

            // 停止计时
            const stop = () => {
                if (updateTimer) {
                    clearTimeout(updateTimer)
                    updateTimer = null
                }
                currentUpdateFn = null
            }

            // 增加已输入字数
            const addWordCount = (count = 1) => {
                wordCount += count
            }

            // 增加击键次数
            const addKeystroke = (isError = false) => {
                totalKeystrokes++
                if (isError) errorKeystrokes++
            }

            // 获取打字速度（字/分）
            const getTypingSpeed = () => {
                if (wordCount === 0 || startTime === 0) return 0
                const elapsedMs = new Date().getTime() - startTime
                return (wordCount * 60 * 1000) / elapsedMs
            }

            // 获取击键速度（次/秒）
            const getKeystrokeSpeed = () => {
                if (totalKeystrokes === 0 || startTime === 0) return 0
                const elapsedSeconds = (new Date().getTime() - startTime) / 1000
                return elapsedSeconds > 0 ? totalKeystrokes / elapsedSeconds : 0
            }

            // 获取键准（%）
            const getAccuracy = () => {
                if (totalKeystrokes === 0) return 100
                return ((totalKeystrokes - errorKeystrokes) / totalKeystrokes) * 100
            }

            // 获取当前统计
            const getStats = () => ({
                typingSpeed: getTypingSpeed(),
                keystrokeSpeed: getKeystrokeSpeed(),
                accuracy: getAccuracy(),
                wordCount,
                totalKeystrokes,
                errorKeystrokes
            })

            // 更新指标显示
            const updateMetrics = () => {
                if (currentUpdateFn) {
                    currentUpdateFn()
                }
                updateTimer = setTimeout(updateMetrics, 500)
            }

            // 格式化显示的函数
            const formatDisplay = (stats) => ({
                speed: `速度：${stats.typingSpeed.toFixed(2)}字/分`,
                keystroke: `击键：${stats.keystrokeSpeed.toFixed(2)}次/秒`,
                accuracy: `键准：${stats.accuracy.toFixed(1)}%`,
                progress: wordCount
            })

            // 通用指标更新函数
            const updateDisplay = (elementIds) => {
                const stats = getStats()
                const display = formatDisplay(stats)

                if (elementIds.speed) {
                    const el = typeof elementIds.speed === 'string' ? (UIComponents?.get?.(elementIds.speed) || document.getElementById(elementIds.speed)) : elementIds.speed
                    if (el) el.textContent = display.speed
                }
                if (elementIds.keystroke) {
                    const el = typeof elementIds.keystroke === 'string' ? (UIComponents?.get?.(elementIds.keystroke) || document.getElementById(elementIds.keystroke)) : elementIds.keystroke
                    if (el) el.textContent = display.keystroke
                }
                if (elementIds.accuracy) {
                    const el = typeof elementIds.accuracy === 'string' ? (UIComponents?.get?.(elementIds.accuracy) || document.getElementById(elementIds.accuracy)) : elementIds.accuracy
                    if (el) el.textContent = display.accuracy
                }
                if (elementIds.progress) {
                    const el = typeof elementIds.progress === 'string' ? (UIComponents?.get?.(elementIds.progress) || document.getElementById(elementIds.progress)) : elementIds.progress
                    if (el) el.textContent = `\t进度：${display.progress}字`
                }
            }

            return {
                reset,
                start,
                stop,
                addWordCount,
                addKeystroke,
                getStats,
                formatDisplay,
                updateDisplay
            }
        })()

        // ============================================
        // 应用状态管理
        // ============================================
        const AppState = (() => {
            const defaultState = () => ({
                curInputMax: 0,
                curInputIndex: 0,
                curTab: 0,
                totalWords: [],
                totalIndex: 0,
                inputTimer: null,
                rawAreaFonts: null,
                cleanupHandlers: []
            })

            let state = defaultState()

            const reset = () => {
                if (state.inputTimer) clearTimeout(state.inputTimer)
                state.cleanupHandlers.forEach(fn => fn())
                state = { ...defaultState(), rawAreaFonts: state.rawAreaFonts }
            }

            const addCleanup = (fn) => {
                state.cleanupHandlers.push(fn)
            }

            const get = (key) => state[key]
            const set = (key, value) => { state[key] = value }

            return { reset, addCleanup, get, set, state }
        })()

        // ============================================
        // UI 组件模块（统一管理 DOM 模板和元素引用）
        // ============================================
        const UIComponents = (() => {
            let currentRefs = {}

            // 初始化 DOM 引用缓存
            const initRefs = (ids = []) => {
                currentRefs = {}
                ids.forEach(id => {
                    currentRefs[id] = document.getElementById(id)
                })
                return currentRefs
            }

            // 获取 DOM 元素
            const get = (id) => currentRefs[id] || document.getElementById(id)

            // 渲染公共统计栏
            const renderStatsBar = (prefix = '') => `
                <div class="stats-bar">
                    ${prefix ? `
                        <span id="${prefix}SpeedLabel"></span>
                        <span id="${prefix}KeystrokeSpeedLabel">击键：0.00次/秒</span>
                        <span id="${prefix}AccuracyLabel">键准：100%</span>
                    ` : `
                        <span id="progressLabel"></span>
                        <span id="speedLabel"></span>
                        <span id="keystrokeSpeedLabel">击键：0.00次/秒</span>
                        <span id="accuracyLabel">键准：100%</span>
                    `}
                </div>`

            // 渲染单选按钮组
            const renderRadioGroup = (modeConfigs, sessionStore) => {
                const savedIdx = sessionStore.get('radioMode', 0)
                return '<div class="radio-group">' +
                    modeConfigs.map((mode, i) => `
                        <label>
                            <input type="radio" name="radiobutton" data-mode="${i}" ${i === savedIdx ? 'checked' : ''}>
                            ${mode.label}
                        </label>
                    `).join('') + '</div>'
            }

            // 渲染练习设置栏
            const renderSettingsBar = (options = {}) => {
                const { showHint = true, oneTimeCount = 30, totalCount = 120, radioHtml = '', selectHtml = '' } = options
                const showHintChecked = SessionStore.get('showHint', showHint) ? 'checked' : ''
                const oc = SessionStore.get('oneTimeCount', oneTimeCount)
                const tc = SessionStore.get('totalCount', totalCount)

                return `<div class="settings-bar">
                    ${selectHtml || `
                        <div class="setting-group">
                            <label for="oneTimeCount">单次字数</label>
                            <input id="oneTimeCount" class="number-input" type="number" min="10" max="500" value="${oc}">
                        </div>
                        <div class="setting-group">
                            <label for="totalCount">练习总数</label>
                            <input id="totalCount" class="number-input" type="number" min="10" max="500" value="${tc}">
                        </div>
                        <label class="checkbox-label" for="showHint">
                            <input id="showHint" type="checkbox" ${showHintChecked}>
                            <span>显示提示</span>
                        </label>
                    `}
                    ${radioHtml}
                </div>`
            }

            // 渲染启动界面
            const renderLaunchScreen = () => `
                <div class="launch-container">
                    <div class="launch-icon">⌨️</div>
                    <h1 class="launch-title">输入法练习工具</h1>
                    <p class="launch-subtitle">选择配置文件开始练习</p>
                    <div class="launch-select">
                        <input type="file" id="configFile" accept=".toml">
                        <label for="configFile" class="file-label">选择文件</label>
                    </div>
                </div>`

            // 渲染主界面结构
            const renderMainLayout = (config, appVersion) => `
                <header class="header">
                    <h1 class="logo">${config.name || '输入法练习工具'}</h1>
                    <div class="version-info-bar">
                        <span class="version-item"><span class="version-label">应用</span><span class="version-value">${appVersion}</span></span>
                        <span class="version-divider"></span>
                        <span class="version-item"><span class="version-label">输入法</span><span class="version-value">${config.version || '-'}</span></span>
                        <span class="version-divider"></span>
                        <span class="version-item"><span class="version-label">配置</span><span class="version-value">${config.config_version || '-'}</span></span>
                    </div>
                </header>
                <nav class="nav-tabs"></nav>
                <main class="main-content"></main>`

            // 渲染分组导航
            const renderGroupNav = (groups, activeGroup) => {
                let html = '<div class="group-nav">'
                Object.keys(groups).forEach(groupName => {
                    const isActive = groupName === activeGroup ? 'active' : ''
                    html += `<button type="button" class="group-tab ${isActive}" data-group="${groupName}">${groupName}</button>`
                })
                html += `<button type="button" class="tab free-tab" id="tab-free">自由练习</button>`
                html += '</div>'
                return html
            }

            // 渲染 Tab 列表
            const renderTabs = (tabs, activeIndex) =>
                '<div class="tab-container">' +
                tabs.map(tab => `<button type="button" class="tab ${tab.index === activeIndex ? 'active' : ''}" id="tab${tab.index}">${tab.label}</button>`).join('') +
                '</div>'

            // 渲染练习模板（字根练习）
            const renderPracticeTemplate = (modeConfigs) => {
                return `<section class="card practice-card">
                    ${renderSettingsBar({ radioHtml: renderRadioGroup(modeConfigs, SessionStore) })}
                    ${renderStatsBar()}
                    <section class="content-area" id="content">
                        <div class="display-area" id="rawArea"></div>
                        <input id="userInput" autocomplete="off" spellcheck="false">
                    </section>
                </section>`
            }

            // 渲染自由练习模板
            const renderFreeTemplate = (textItems = []) => {
                const optionsHtml = textItems.map((item, idx) =>
                    `<option value="${idx}">${item.name}</option>`
                ).join('')
                const selectHtml = `<div class="setting-group"><label for="freeTextSelect">选择文章</label><select id="freeTextSelect" class="text-select">${optionsHtml}</select></div>`

                return `<section class="card practice-card">
                    ${renderSettingsBar({ selectHtml })}
                    ${renderStatsBar('free')}
                    <section class="content-area" id="freeContent">
                        <div class="display-area free-display-area" id="freeArea"></div>
                        <textarea id="freeUserInput" class="free-input" placeholder="自由输入" rows="3" spellcheck="false"></textarea>
                    </section>
                </section>`
            }

            // 渲染帮助内容
            const renderHelpContent = (helpContent) => helpContent || ''

            return {
                initRefs,
                get,
                renderLaunchScreen,
                renderMainLayout,
                renderGroupNav,
                renderTabs,
                renderPracticeTemplate,
                renderFreeTemplate,
                renderHelpContent
            }
        })()

        // ============================================
        // 配置验证模块
        // ============================================
        const ConfigValidator = (() => {
            const schema = {
                name: { type: 'string', default: '输入法练习工具' },
                version: { type: 'string', default: '-' },
                config_version: { type: 'string', default: '-' },
                tabs: { type: 'array', required: true },
                text: { type: 'array', required: true },
                items: { type: 'array', required: true },
                help: { type: 'array', default: [] },
                fonts: { type: 'array', default: [] },
                key_bindings: { type: 'array', default: [] }
            }

            const validate = (config) => {
                const errors = []

                if (!config || typeof config !== 'object') {
                    return { valid: false, errors: ['配置解析失败'] }
                }

                // 验证必填字段
                if (!config.tabs || !Array.isArray(config.tabs)) {
                    errors.push('缺少 tabs 配置')
                }
                if (!config.items || !Array.isArray(config.items)) {
                    errors.push('缺少 items 配置')
                }
                const textItems = config.text || []
                if (!Array.isArray(textItems) || textItems.length === 0) {
                    errors.push('缺少 text 配置')
                } else {
                    textItems.forEach((item, i) => {
                        if (!item.name || typeof item.name !== 'string') {
                            errors.push(`text[${i}] 缺少 name`)
                        }
                        if (!item.content || typeof item.content !== 'string') {
                            errors.push(`text[${i}] 缺少 content`)
                        }
                    })
                }

                // 验证 tabs 结构
                if (config.tabs) {
                    config.tabs.forEach((tab, i) => {
                        if (!tab.label) errors.push(`tabs[${i}] 缺少 label`)
                        if (tab.type === 'help') {
                            // help 类型的 index 应为长度为 1 的数组
                            if (!Array.isArray(tab.index) || tab.index.length !== 1) {
                                errors.push(`tabs[${i}] help 类型的 index 应为长度为 1 的数组`)
                            } else if (tab.index[0] < 0 || tab.index[0] >= (config.help ? config.help.length : 0)) {
                                errors.push(`tabs[${i}] index 超出 help 数组范围`)
                            }
                        } else if (!Array.isArray(tab.index) || tab.index.length === 0) {
                            errors.push(`tabs[${i}] 缺少 index`)
                        }
                        if (typeof tab.group !== 'string') errors.push(`tabs[${i}] group 应为字符串`)
                    })
                }

                return {
                    valid: errors.length === 0,
                    errors,
                    data: config
                }
            }

            return { validate }
        })()

        // ============================================
        // 键盘事件处理模块（共享）
        // ============================================
        const KeyboardHandler = (() => {
            const createHandler = () => {
                const handler = (e) => {
                    // 只在输入框激活时统计
                    const userInput = UIComponents.get('userInput') || UIComponents.get('freeUserInput')
                    if (!userInput || document.activeElement !== userInput) return

                    // Backspace 和 Del 视为错误按键
                    const isError = e.key === 'Backspace' || e.key === 'Delete'
                    MetricsTracker.addKeystroke(isError)
                }
                return handler
            }

            const bind = () => {
                const handler = createHandler()
                document.addEventListener('keydown', handler)
                AppState.addCleanup(() => document.removeEventListener('keydown', handler))
            }

            return { bind }
        })()

        // ============================================
        // 会话存储封装
        // ============================================
        const SessionStore = (() => {
            const get = (key, defaultVal) => {
                const val = sessionStorage.getItem(key)
                if (val === null) return defaultVal
                // 处理布尔值
                if (val === 'true') return true
                if (val === 'false') return false
                // 处理数字
                const num = parseFloat(val)
                return isNaN(num) ? val : num
            }

            const set = (key, value) => {
                sessionStorage.setItem(key, String(value))
            }

            return { get, set }
        })()

        // ============================================
        // 工具函数
        // ============================================
        const Utils = (() => {
            const shuffleArray = (arr) => {
                const indices = [...Array(arr.length).keys()]
                for (let i = 0; i < indices.length; i++) {
                    const j = Math.floor(Math.random() * indices.length)
                    ;[indices[i], indices[j]] = [indices[j], indices[i]]
                }
                return indices.map(i => arr[i])
            }

            const generateRandomIndices = (size, max) => {
                const result = []
                for (let i = 0; i < size; i++) { result.push(Math.floor(Math.random() * max)) }
                return result
            }

            const debounce = (fn, delay) => {
                let timer = null
                return (...args) => {
                    if (timer) clearTimeout(timer)
                    timer = setTimeout(() => fn(...args), delay)
                }
            }

            // 根据索引列表获取单词
            const getWordsByIndex = (items, indices) => {
                const words = []
                for (const i of indices) {
                    const objs = items[i]
                    for (const key in objs) {
                        objs[key].forEach(code => words.push({ key, code }))
                    }
                }
                return words
            }

            // 构建分组数据
            const buildGroups = (tabs, defaultGroup = '默认') => {
                const groups = {}
                tabs.forEach((tab, i) => {
                    const groupName = tab.group || defaultGroup
                    if (!groups[groupName]) groups[groupName] = []
                    groups[groupName].push({ ...tab, index: i })
                })
                return groups
            }

            return { shuffleArray, generateRandomIndices, debounce, getWordsByIndex, buildGroups }
        })()

        // ============================================
        // 主应用逻辑
        // ============================================
        const App = (() => {
            const appVersion = "1.0.0"
            let config = {}
            let compiledKeyBindings = []

            const modeConfigs = [
                { name: "sequential", label: "顺序单次", handler: (words) => words },
                { name: "shuffled", label: "乱序单次", handler: (words) => Utils.shuffleArray(words) },
                { name: "repeated", label: "乱序重复", handler: (words) => Utils.generateRandomIndices(SessionStore.get("totalCount", 120), words.length).map(i => words[i]) }
            ]

            // 清理资源
            const cleanup = () => {
                // 清理 FreeModule
                FreeModule.cleanup()
                MetricsTracker.reset()
                AppState.reset()
            }

            // 编译快捷键
            const compileKeyBindings = () => {
                compiledKeyBindings = []
                const bindings = (config && config.key_bindings) ? config.key_bindings : []
                for (const binding of bindings) {
                    const key = binding.key.toLowerCase()
                    const parts = key.split('+').map(p => p.trim()).filter(p => p)
                    const modifiers = parts.filter(p => ['ctrl', 'alt', 'shift', 'meta'].includes(p))
                    const keyPart = parts.find(p => !['ctrl', 'alt', 'shift', 'meta'].includes(p))
                    if (keyPart) {
                        compiledKeyBindings.push({ modifiers, keyPart, command: binding.command })
                    }
                }
            }

            // 初始化快捷键
            const initKeyBindings = () => {
                compileKeyBindings()
                if (compiledKeyBindings.length === 0) return

                const handler = (e) => {
                    for (const binding of compiledKeyBindings) {
                        const ctrlMatch = binding.modifiers.includes('ctrl') ? e.ctrlKey : !e.ctrlKey
                        const altMatch = binding.modifiers.includes('alt') ? e.altKey : !e.altKey
                        const shiftMatch = binding.modifiers.includes('shift') ? e.shiftKey : !e.shiftKey
                        const metaMatch = binding.modifiers.includes('meta') ? e.metaKey : !e.metaKey
                        const keyMatch = e.key.toLowerCase() === binding.keyPart

                        if (ctrlMatch && altMatch && shiftMatch && metaMatch && keyMatch) {
                            e.preventDefault()
                            if (binding.command === 'tab_reload') {
                                startPractice(AppState.get('curTab'))
                            }
                            break
                        }
                    }
                }
                document.addEventListener('keydown', handler)
                AppState.addCleanup(() => document.removeEventListener('keydown', handler))
            }

            // 更新指标显示（使用 MetricsTracker）
            const updateMetricsDisplay = () => {
                MetricsTracker.updateDisplay({
                    speed: UIComponents.get('speedLabel'),
                    keystroke: UIComponents.get('keystrokeSpeedLabel'),
                    accuracy: UIComponents.get('accuracyLabel'),
                    progress: UIComponents.get('progressLabel')
                })
                // 单独更新进度显示（需要 totalWords 长度）
                const progressLabel = UIComponents.get('progressLabel')
                if (progressLabel) {
                    progressLabel.textContent = `\t进度：${MetricsTracker.getStats().wordCount}/${AppState.get('totalWords').length}字`
                }
            }

            // 启动指标跟踪
            const startMetricsTracking = () => {
                MetricsTracker.reset()
                MetricsTracker.start(updateMetricsDisplay)
            }

            // 停止指标跟踪
            const stopMetricsTracking = () => {
                MetricsTracker.stop()
            }

            // 更新占位符
            const updatePlaceholder = () => {
                const curInputIndex = AppState.get('curInputIndex')
                const word = UIComponents.get(`word${curInputIndex}`)
                if (word) {
                    const showHint = SessionStore.get('showHint', true)
                    UIComponents.get('userInput').setAttribute("placeholder", showHint ? word.getAttribute("key") : "")
                }
            }

            // 获取当前单词
            const getCurrentWord = () => {
                const curInputIndex = AppState.get('curInputIndex')
                const curInputMax = AppState.get('curInputMax')
                if (curInputIndex >= curInputMax) return null
                return UIComponents.get(`word${curInputIndex}`)
            }

            // 加载下一批
            const loadNextBatch = () => {
                const totalWords = AppState.get('totalWords')
                const totalIndex = AppState.get('totalIndex')
                const lastCount = totalWords.length - totalIndex
                if (lastCount <= 0) return false

                const oneTimeCount = SessionStore.get('oneTimeCount', 30)
                const wordNeed = Math.min(lastCount, oneTimeCount)
                AppState.set('curInputMax', wordNeed)
                AppState.set('curInputIndex', 0)

                const rawArea = UIComponents.get('rawArea')
                rawArea.innerHTML = ''

                totalWords.slice(totalIndex, totalIndex + wordNeed).forEach((word, idx) => {
                    const span = document.createElement("span")
                    span.textContent = word.code
                    span.setAttribute("key", word.key)
                    span.id = `word${idx}`
                    span.style.color = "var(--text-tertiary)"
                    rawArea.appendChild(span)
                })

                AppState.set('totalIndex', totalIndex + wordNeed)
                updatePlaceholder()
                return true
            }

            // 处理输入
            const handleInput = () => {
                const curInputMax = AppState.get('curInputMax')
                const curInputIndex = AppState.get('curInputIndex')

                if (curInputIndex >= curInputMax) return

                let inputTimer = AppState.get('inputTimer')
                if (inputTimer) clearTimeout(inputTimer)

                inputTimer = setTimeout(() => {
                    const word = getCurrentWord()
                    if (!word) {
                        AppState.set('inputTimer', null)
                        return
                    }

                    const key = word.getAttribute("key")
                    const userInput = UIComponents.get('userInput')
                    const val = userInput.value

                    if (val.length < key.length) {
                        AppState.set('inputTimer', null)
                        return
                    }

                    if (val.toLowerCase() === key) {
                        MetricsTracker.start()
                        MetricsTracker.addWordCount()
                        AppState.set('curInputIndex', curInputIndex + 1)

                        const totalWords = AppState.get('totalWords')
                        UIComponents.get('progressLabel').textContent = `\t进度：${MetricsTracker.getStats().wordCount}/${totalWords.length}字`
                        word.style.color = "var(--text-primary)"
                        userInput.value = ""
                        updatePlaceholder()
                    } else {
                        MetricsTracker.addKeystroke(true) // 错误按键
                        word.style.color = "var(--error)"
                        userInput.value = ""
                        userInput.setAttribute("placeholder", key)
                    }

                    AppState.set('inputTimer', null)

                    if (AppState.get('curInputIndex') >= AppState.get('curInputMax')) {
                        if (!loadNextBatch()) {
                            userInput.setAttribute("disabled", "true")
                            stopMetricsTracking()
                        }
                    }
                }, 50)

                AppState.set('inputTimer', inputTimer)
            }

            // 初始化DOM引用
            const initDomReferences = () => {
                const userInput = UIComponents.get('userInput')

                if (userInput) {
                    userInput.oninput = handleInput
                }

                // 使用共享的键盘事件处理器
                KeyboardHandler.bind()

                const oneTimeCount = UIComponents.get("oneTimeCount")
                const totalCount = UIComponents.get("totalCount")

                if (oneTimeCount) {
                    oneTimeCount.addEventListener('change', () => startPractice(AppState.get('curTab')))
                }
                if (totalCount) {
                    totalCount.addEventListener('change', () => startPractice(AppState.get('curTab')))
                }

                // 点击聚焦
                const clickHandler = (e) => {
                    if (userInput && document.activeElement !== userInput &&
                        e.target.id !== 'oneTimeCount' &&
                        e.target.id !== 'totalCount') {
                        userInput.focus({ preventScroll: true })
                    }
                }
                document.addEventListener('click', clickHandler)
                AppState.addCleanup(() => document.removeEventListener('click', clickHandler))
            }

            // 更新标签样式
            const updateTabStyles = (activateIdx) => {
                document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"))
                if (activateIdx !== null) {
                    if (activateIdx === 'free') {
                        document.getElementById('tab-free').classList.add("active")
                    } else {
                        UIComponents.get(`tab${activateIdx}`).classList.add("active")
                    }
                }
            }

            // 切换输入区域
            const toggleInputArea = (val) => {
                const contentCard = UIComponents.get('content') || UIComponents.get('freeContent')
                if (contentCard) {
                    contentCard.style.display = val ? "flex" : "none"
                }
                const userInput = UIComponents.get('userInput') || UIComponents.get('freeUserInput')
                if (userInput) userInput.value = ""
            }

            // 显示模板
            const showTemplate = (templateId, helpIndex = 0, textItems = [], modeConfigs = []) => {
                const mainEl = document.querySelector("main")

                if (templateId === "help-template") {
                    mainEl.innerHTML = UIComponents.renderHelpContent(config.help?.[helpIndex])
                    return
                }

                let content = ''
                if (templateId === "practice-template") {
                    content = UIComponents.renderPracticeTemplate(modeConfigs)
                } else if (templateId === "free-template") {
                    content = UIComponents.renderFreeTemplate(textItems)
                }

                mainEl.innerHTML = content

                if (templateId === "practice-template") {
                    bindPracticeTemplateEvents()
                }
            }



                                                // 绑定练习模板事件
                                    const bindPracticeTemplateEvents = () => {
                                        // 单选按钮事件
                                        const radioButtons = document.querySelectorAll('input[name="radiobutton"]')
                                        radioButtons.forEach(input => {
                                            input.onclick = () => {
                                                const modeIdx = parseInt(input.dataset.mode)
                                                SessionStore.set('radioMode', modeIdx)
                                                startPractice(AppState.get('curTab'))
                                            }
                                        })
                        
                                        // 提示复选框
                                        const hintCheckbox = document.getElementById('showHint')
                                        if (hintCheckbox) {
                                            hintCheckbox.onchange = (e) => {
                                                SessionStore.set('showHint', e.target.checked)
                                                updatePlaceholder()
                                            }
                                        }
                        
                                        // 数字输入框
                                        const oneTimeCountInput = document.getElementById('oneTimeCount')
                                        if (oneTimeCountInput) {
                                            oneTimeCountInput.onchange = (e) => SessionStore.set('oneTimeCount', e.target.value)
                                        }
                        
                                        const totalCountInput = document.getElementById('totalCount')
                                        if (totalCountInput) {
                                            totalCountInput.onchange = (e) => SessionStore.set('totalCount', e.target.value)
                                        }
                                    }
            // 初始化标签
            const initTabs = () => {
                const nav = document.querySelector(".nav-tabs")

                // 按 group 分组
                const groups = Utils.buildGroups(config.tabs)
                const firstGroup = Object.keys(groups)[0] || null

                // 渲染分组导航（包含 free tab）
                nav.innerHTML = UIComponents.renderGroupNav(groups, null)

                // 绑定 free tab 点击事件
                const freeTab = document.getElementById('tab-free')
                if (freeTab) {
                    freeTab.onclick = () => startPractice('free')
                }

                // 添加当前分组的 tabs 容器
                const tabContainer = document.createElement("div")
                tabContainer.className = "tab-container"
                nav.appendChild(tabContainer)

                // 绑定分组点击事件
                document.querySelectorAll('.group-tab').forEach(btn => {
                    btn.onclick = () => switchGroup(btn.dataset.group)
                })

                // 默认显示第一个分组
                if (firstGroup) {
                    switchGroup(firstGroup, false)
                }
            }

            // 切换分组
            const switchGroup = (groupName, updateActiveTab = true) => {
                // 更新分组样式
                const groupTab = document.querySelector(`.group-tab[data-group="${groupName}"]`)
                if (groupTab) {
                    document.querySelectorAll(".group-tab").forEach(t => t.classList.remove("active"))
                    groupTab.classList.add("active")
                }

                // 获取分组数据
                const groups = Utils.buildGroups(config.tabs)
                const tabs = groups[groupName] || []
                const tabContainer = document.querySelector(".tab-container")
                tabContainer.innerHTML = UIComponents.renderTabs(tabs, null)

                // 绑定 tab 点击事件
                tabs.forEach(tab => {
                    const btn = document.getElementById(`tab${tab.index}`)
                    if (btn) {
                        btn.onclick = () => {
                            if (tab.type === "help") {
                                displayHelp(tab.index[0])
                            } else {
                                startPractice(tab.index)
                            }
                        }
                    }
                })

                // 激活该分组的第一个 tab
                if (updateActiveTab && tabs.length > 0) {
                    const firstTab = tabs[0]
                    if (firstTab.type === "help") {
                        displayHelp(firstTab.index[0])
                    } else {
                        startPractice(firstTab.index)
                    }
                }
            }

            // 显示帮助
            const displayHelp = (helpIndex = 0) => {
                stopMetricsTracking()
                updateTabStyles(helpIndex)
                const mainEl = document.querySelector("main")
                mainEl.innerHTML = UIComponents.renderHelpContent(config.help?.[helpIndex])

                // 切换到 help 所在的分组
                const helpTab = config.tabs.find(t => t.type === 'help' && t.index[0] === helpIndex)
                if (helpTab) {
                    const groupName = helpTab.group || '默认'
                    const groupTab = document.querySelector(`.group-tab[data-group="${groupName}"]`)
                    if (groupTab) {
                        document.querySelectorAll(".group-tab").forEach(t => t.classList.remove("active"))
                        groupTab.classList.add("active")
                    }
                }
            }

            // 辅助函数：更新分组高亮
            const updateGroupHighlight = (groupName) => {
                const groupTab = document.querySelector(`.group-tab[data-group="${groupName}"]`)
                if (groupTab) {
                    document.querySelectorAll(".group-tab").forEach(t => t.classList.remove("active"))
                    groupTab.classList.add("active")
                }
            }

            // 开始练习
            const startPractice = (val, type = 'default') => {
                cleanup()
                updateTabStyles(val)

                // 判断是否为 free 模式
                const isFreeType = val === 'free'

                // 根据类型显示不同的模板
                if (isFreeType) {
                    const textItems = (config.text || []).map(item => ({ name: item.name, content: item.content }))
                    showTemplate("free-template", 0, textItems)
                } else {
                    showTemplate("practice-template", 0, [], modeConfigs)
                }

                // 初始化 DOM 引用缓存
                UIComponents.initRefs([
                    'rawArea', 'userInput', 'freeUserInput',
                    'speedLabel', 'progressLabel', 'keystrokeSpeedLabel', 'accuracyLabel',
                    'freeSpeedLabel', 'freeKeystrokeSpeedLabel', 'freeAccuracyLabel',
                    'oneTimeCount', 'totalCount', 'showHint'
                ])

                initDomReferences()
                initKeyBindings() // 重新注册快捷键（cleanup会移除）
                toggleInputArea(true)

                const rawArea = UIComponents.get('rawArea') || UIComponents.get('freeArea')
                const userInput = isFreeType
                    ? UIComponents.get('freeUserInput')
                    : UIComponents.get('userInput')

                if (!rawArea || !userInput) {
                    console.error('startPractice: rawArea or userInput not found')
                    return
                }

                rawArea.style.fontFamily = AppState.get('rawAreaFonts') || 'inherit'
                userInput.removeAttribute("disabled")

                if (!isFreeType) {
                    updatePlaceholder()
                }
                userInput.focus({ preventScroll: true })

                AppState.set('totalIndex', 0)
                AppState.set('curTab', val)

                // 判断是否为 free 类型
                if (isFreeType) {
                    // 使用自由练习模块，从 config.text 获取文章内容
                    const textItems = (config.text || []).map(item => ({ name: item.name, content: item.content }))
                    const freeText = textItems.length > 0 ? textItems[0].content : ''
                    FreeModule.init(freeText, textItems)
                    FreeModule.bindEvents()
                } else {
                    // 原来的字根练习逻辑
                    const allWords = Utils.getWordsByIndex(config.items, config.tabs[val].index)
                    const modeIdx = SessionStore.get('radioMode', 0)
                    AppState.set('totalWords', modeConfigs[modeIdx].handler(allWords))

                    loadNextBatch()
                    const progressLabel = UIComponents.get('progressLabel')
                    if (progressLabel) {
                        progressLabel.textContent = `\t进度：0/${AppState.get('totalWords').length}字`
                    }

                    // 启动指标跟踪
                    startMetricsTracking()
                }

                // 切换到当前 tab 所在的分组（free 模式不切换分组）
                if (!isFreeType) {
                    const curTabConfig = config.tabs[val]
                    if (curTabConfig) {
                        updateGroupHighlight(curTabConfig.group || '默认')
                    }
                }
            }

            // 加载配置
            const loadConfig = async (text, filePath) => {
                // 检查缓存
                if (ConfigCache.isSameConfig(filePath, text)) {
                    // 刷新快捷键
                    initTabs()
                    initKeyBindings()
                    displayHelp()
                    return true
                }

                let newConfig
                try {
                    newConfig = TOML.parse(text)
                } catch (err) {
                    console.error('TOML解析失败:', err)
                    throw new Error('配置解析失败: ' + err.message)
                }

                // 验证配置
                const validation = ConfigValidator.validate(newConfig)
                if (!validation.valid) {
                    console.error('配置验证失败:', validation.errors)
                    throw new Error('配置验证失败:\n' + validation.errors.join('\n'))
                }

                config = validation.data
                ConfigCache.set(filePath, text)

                // 设置标题和版本
                document.title = config.name || '输入法练习工具'

                // 恢复主界面结构
                document.querySelector('.app-container').innerHTML = UIComponents.renderMainLayout(config, appVersion)

                // 初始化
                initTabs()
                initKeyBindings()
                displayHelp(0)

                // 加载字体
                try {
                    const fontFamily = await FontLoader.loadAll(config.fonts)
                    AppState.set('rawAreaFonts', fontFamily)
                } catch (err) {
                    console.error('字体加载失败:', err)
                }

                return true
            }

            // 选择配置
            const onConfigSelected = async (e) => {
                const file = e.target.files[0]
                if (!file) return

                try {
                    const text = await file.text()
                    await loadConfig(text, file.name)
                } catch (err) {
                    console.error('加载配置失败:', err, err.stack)
                    alert('加载配置失败: ' + err.message + '\n请查看控制台获取详情')
                }
            }

            // 显示启动界面
            const showLaunchScreen = () => {
                document.querySelector('.app-container').innerHTML = UIComponents.renderLaunchScreen()
                UIComponents.get('configFile').addEventListener('change', onConfigSelected)
            }

            // 初始化
            const init = () => {
                cleanup()
                showLaunchScreen()
            }

            return { init }
        })()

        // ============================================
        // 自由练习模块（free tab 类型专用）
        // ============================================
        const FreeModule = (() => {
            let currentText = '' // 当前练习的文本
            let inputTimer = null // 防抖定时器
            const elementIds = { speed: 'freeSpeedLabel', keystroke: 'freeKeystrokeSpeedLabel', accuracy: 'freeAccuracyLabel' }

            // 初始化自由练习
            const init = (text, textItems = []) => {
                currentText = text

                const freeArea = document.getElementById('freeArea')
                const userInput = document.getElementById('freeUserInput')
                const textSelect = document.getElementById('freeTextSelect')

                if (!freeArea || !userInput) {
                    console.error('FreeModule init failed: freeArea or userInput not found')
                    return
                }

                // 清空并重新渲染 freeArea
                freeArea.innerHTML = ''
                freeArea.style.fontFamily = AppState.get('rawAreaFonts') || 'inherit'

                // 为每个字创建显示区域
                text.split('').forEach((char, idx) => {
                    const span = document.createElement('span')
                    span.id = `free-char-${idx}`
                    span.textContent = char
                    span.dataset.char = char
                    freeArea.appendChild(span)
                })

                // 清空输入框
                userInput.value = ''
                userInput.focus({ preventScroll: true })

                // 重置指标
                MetricsTracker.reset()

                // 启用输入框
                userInput.removeAttribute('disabled')

                // 重置指标显示
                MetricsTracker.updateDisplay({ speed: 'freeSpeedLabel', keystroke: 'freeKeystrokeSpeedLabel', accuracy: 'freeAccuracyLabel' })
                const speedLabel = document.getElementById('freeSpeedLabel')
                if (speedLabel) speedLabel.textContent = ""

                // 绑定下拉框选择事件
                if (textSelect && textItems.length > 0) {
                    textSelect.onchange = (e) => {
                        const idx = parseInt(e.target.value)
                        const selectedText = textItems[idx]
                        if (selectedText) {
                            // 重置并加载新内容
                            init(selectedText.content, textItems)
                            FreeModule.bindEvents()
                        }
                    }
                }
            }

            // 处理用户输入
            const handleInput = () => {
                const userInput = document.getElementById('freeUserInput')
                if (!userInput) return
                const val = userInput.value

                // 清除之前的防抖定时器
                if (inputTimer) {
                    clearTimeout(inputTimer)
                }

                inputTimer = setTimeout(() => {
                    // 只对比用户输入的长度的内容
                    const inputLen = Math.min(val.length, currentText.length)

                    // 找到用户输入范围内第一个不匹配的位置
                    let firstMismatchIndex = -1
                    for (let i = 0; i < inputLen; i++) {
                        if (val[i] !== currentText[i]) {
                            firstMismatchIndex = i
                            break
                        }
                    }

                    // 更新显示状态
                    for (let i = 0; i < currentText.length; i++) {
                        const span = document.getElementById(`free-char-${i}`)
                        if (!span) continue

                        const expectedChar = currentText[i]
                        span.textContent = expectedChar
                        span.style.background = 'transparent'
                        span.classList.remove('error')

                        if (i < val.length) {
                            // 在用户输入范围内的文字
                            if (firstMismatchIndex !== -1 && i >= firstMismatchIndex) {
                                // 第一个不匹配位置变红
                                span.style.color = 'var(--error)'
                                span.style.background = 'var(--error-subtle)'
                                span.classList.add('error')
                            } else {
                                // 匹配的文字保持正常
                                span.style.color = 'var(--text-primary)'
                            }
                        } else {
                            // 超出用户输入长度的文字，恢复原始显示
                            span.style.color = 'var(--text-tertiary)'
                        }
                    }

                    // 启动指标计时器
                    if (val.length > 0 && MetricsTracker.getStats().wordCount === 0) {
                        MetricsTracker.start(() => MetricsTracker.updateDisplay(elementIds))
                    }

                    inputTimer = null
                }, 30)
            }

            // 绑定事件
            const bindEvents = () => {
                const userInput = document.getElementById('freeUserInput')
                if (userInput) {
                    // 输入法组合期间不处理对比
                    let isComposing = false
                    userInput.addEventListener('compositionstart', () => {
                        isComposing = true
                    })
                    userInput.addEventListener('compositionend', (e) => {
                        isComposing = false
                        // 组合结束后立即处理输入
                        handleInput()
                    })

                    userInput.oninput = () => {
                        // 输入法组合期间不处理
                        if (isComposing) return
                        handleInput()
                    }
                }

                // 使用共享的键盘事件处理器
                KeyboardHandler.bind()
            }

            // 清理资源
            const cleanup = () => {
                if (inputTimer) {
                    clearTimeout(inputTimer)
                    inputTimer = null
                }
                MetricsTracker.stop()
                currentText = ''
            }

            return { init, bindEvents, cleanup, handleInput }
        })()

        // 启动应用
        window.addEventListener('load', App.init)
    </script>
    <style>
            :root {
                --primary: #6366f1;
                --primary-subtle: #eef2ff;
                --error: #ef4444;
                --error-subtle: #fee2e2;
                --bg: #f8fafc;
                --card-bg: #ffffff;
                --text-primary: #1e293b;
                --text-secondary: #64748b;
                --text-tertiary: #cbd5e1;
                --border: #e2e8f0;
                --shadow: 0 4px 10px rgba(15, 23, 42, 0.08);
                --radius: 12px;
                --radius-sm: 8px;
                --focus-ring: 0 0 0 3px rgba(99, 102, 241, 0.16);
            }

            *, *::before, *::after { box-sizing: border-box; }
            html, body { margin: 0; padding: 0; }
            html { font-size: 16px; line-height: 1.6; }
            body { min-height: 100vh; padding: 24px; color: var(--text-primary); background: var(--bg); }
            button, input, select, textarea { font: inherit; }

            #font-container {
                position: absolute;
                width: 0;
                height: 0;
                overflow: hidden;
                visibility: hidden;
                font-family: '宋体', 'Yuniversus', 'WenJin Mincho Plane 0', 'WenJin Mincho Plane 2', 'WenJin Mincho Plane 3', 'TH-Times', 'TH-Tshyn-P0', 'TH-Tshyn-P1', 'TH-Tshyn-P2', 'TH-Tshyn-P16', 'SimSun-ExtB', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }

            .app-container { width: min(920px, 100%); margin: 0 auto; }
            .main-content { display: grid; gap: 20px; }

            .launch-container {
                min-height: 70vh;
                display: grid;
                place-content: center;
                gap: 14px;
                text-align: center;
            }
            .launch-icon { font-size: 4.5rem; line-height: 1; }
            .launch-title { margin: 0; font-size: clamp(2rem, 4vw, 2.5rem); font-weight: 700; }
            .launch-subtitle { margin: 0 0 18px; color: var(--text-secondary); }
            .launch-select input[type="file"] { display: none; }
            .file-label {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 12px 28px;
                border-radius: var(--radius);
                background: var(--primary);
                color: #fff;
                font-weight: 600;
                cursor: pointer;
                transition: transform 0.2s ease, box-shadow 0.2s ease;
            }
            .file-label:hover { transform: translateY(-1px); box-shadow: 0 8px 16px rgba(99, 102, 241, 0.28); }

            .header { text-align: center; margin-bottom: 20px; }
            .logo { margin: 0 0 10px; font-size: clamp(1.65rem, 3vw, 2rem); font-weight: 700; }
            .version-info-bar {
                display: inline-flex;
                align-items: center;
                padding: 8px 14px;
                border-radius: 999px;
                background: var(--card-bg);
                box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
            }
            .version-item { display: inline-flex; gap: 6px; align-items: center; padding: 0 6px; }
            .version-label { color: var(--text-tertiary); font-size: 0.75rem; font-weight: 600; text-transform: uppercase; }
            .version-value { color: var(--text-secondary); font-size: 0.86rem; font-weight: 600; }
            .version-divider { width: 1px; height: 16px; background: var(--border); }

            .nav-tabs {
                margin-bottom: 20px;
                padding: 10px;
                display: grid;
                gap: 8px;
                border-radius: var(--radius);
                background: var(--card-bg);
                box-shadow: var(--shadow);
            }
            .group-nav {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                gap: 6px;
                padding-bottom: 8px;
                border-bottom: 1px solid var(--border);
            }
            .tab-container { display: flex; flex-wrap: wrap; gap: 6px; }
            .group-tab, .tab {
                border: none;
                border-radius: var(--radius-sm);
                padding: 7px 14px;
                background: transparent;
                color: var(--text-secondary);
                font-size: 0.86rem;
                font-weight: 600;
                cursor: pointer;
                transition: 0.18s ease;
            }
            .group-tab:hover, .tab:hover { color: var(--primary); background: var(--primary-subtle); }
            .group-tab.active, .tab.active { color: #fff; background: var(--primary); }
            .free-tab {
                margin-left: auto;
                border: 1px solid rgba(99, 102, 241, 0.35);
                color: var(--primary);
            }

            .card {
                padding: 20px;
                border-radius: var(--radius);
                background: var(--card-bg);
                box-shadow: var(--shadow);
            }
            .practice-card { display: grid; gap: 16px; }

            .settings-bar { display: flex; flex-wrap: wrap; gap: 12px 18px; align-items: center; }
            .setting-group { display: inline-flex; align-items: center; gap: 8px; }
            .setting-group label { font-size: 0.88rem; color: var(--text-secondary); font-weight: 600; }
            .radio-group { display: flex; flex-wrap: wrap; gap: 14px; }
            .radio-group label, .checkbox-label {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-size: 0.88rem;
                color: var(--text-secondary);
                cursor: pointer;
            }
            .checkbox-label { font-weight: 600; }
            .radio-group input[type="radio"], .checkbox-label input[type="checkbox"] {
                width: 16px;
                height: 16px;
                margin: 0;
                accent-color: var(--primary);
                cursor: pointer;
            }

            .text-select, .number-input {
                border: 1px solid var(--border);
                border-radius: var(--radius-sm);
                background: var(--card-bg);
                color: var(--text-primary);
                transition: border-color 0.16s ease, box-shadow 0.16s ease;
            }
            .text-select { padding: 8px 10px; }
            .number-input { width: 76px; padding: 8px 10px; text-align: center; font-weight: 600; }
            .text-select:focus, .number-input:focus, #userInput:focus, .free-input:focus {
                border-color: var(--primary);
                box-shadow: var(--focus-ring);
                outline: none;
            }

            .stats-bar {
                display: grid;
                gap: 8px 12px;
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                padding: 12px 16px;
                border-radius: var(--radius-sm);
                background: var(--primary-subtle);
                color: var(--primary);
                font-size: 0.93rem;
                font-weight: 600;
            }
            .stats-bar span { text-align: center; }

            .content-area { display: grid; gap: 16px; }
            .display-area {
                min-height: 260px;
                padding: 24px;
                border-radius: var(--radius);
                background: var(--bg);
                font-size: 2.2rem;
                font-weight: 600;
                line-height: 2;
                text-align: center;
                letter-spacing: 0.08em;
                word-break: keep-all;
            }
            .display-area span {
                display: inline-block;
                margin: 4px 10px;
                padding: 6px 12px;
                border-radius: var(--radius-sm);
                transition: 0.2s;
            }
            .free-display-area {
                min-height: 300px;
                font-size: 2rem;
                line-height: 1.65;
                text-align: left;
                word-break: break-word;
                overflow-wrap: anywhere;
            }
            .free-display-area span { margin: 0; padding: 0; display: inline; color: var(--text-tertiary); }
            .free-display-area span.error { color: var(--error); background: var(--error-subtle); border-radius: 4px; }

            #userInput {
                width: min(320px, 100%);
                margin: 8px auto 0;
                padding: 14px 18px;
                border: 1px solid var(--border);
                border-radius: var(--radius);
                background: var(--card-bg);
                color: var(--text-primary);
                text-align: center;
                font-size: 1.22rem;
                font-weight: 600;
                letter-spacing: 0.15em;
                caret-color: transparent;
                transition: border-color 0.16s ease, box-shadow 0.16s ease;
            }
            #userInput:disabled { opacity: 0.55; cursor: not-allowed; }

            .free-input {
                width: 100%;
                min-height: 180px;
                padding: 10px 14px;
                border: 1px solid var(--border);
                border-radius: var(--radius);
                background: var(--bg);
                color: var(--text-primary);
                line-height: 1.7;
                font-size: 1.4rem;
                resize: vertical;
                transition: border-color 0.16s ease, box-shadow 0.16s ease;
            }
            .free-input::placeholder { color: var(--text-tertiary); }
            #freeUserInput { padding: 0; border: none; background: transparent; border-radius: 0; }
            #freeUserInput:focus { box-shadow: none; }

            .help-block { margin-bottom: 12px; padding: 14px 16px; border-radius: var(--radius-sm); background: var(--bg); }
            .help-block h3 { margin: 0 0 8px; font-size: 1rem; }
            .help-block p { margin: 0 0 10px; color: var(--text-secondary); font-size: 0.9rem; }
            .help-items { display: grid; gap: 8px; }
            .help-items code {
                display: inline-flex;
                align-self: flex-start;
                padding: 4px 9px;
                border-radius: 6px;
                background: var(--primary-subtle);
                color: var(--primary);
                font-weight: 700;
            }

            @media (max-width: 640px) {
                body { padding: 14px; }
                .nav-tabs { padding: 8px; }
                .card { padding: 16px; }
                .settings-bar { flex-direction: column; align-items: flex-start; }
                .radio-group { width: 100%; }
                .free-tab { margin-left: 0; }
                .display-area { padding: 18px; font-size: 1.65rem; }
                .free-display-area { font-size: 1.65rem; }
                .stats-bar { grid-template-columns: 1fr; }
            }
        </style>

</head>

<body>
    <div id="font-container" aria-hidden="true"></div>
    <div class="app-container"></div>
</body>

</html>
